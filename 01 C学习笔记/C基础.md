# 1  C语言概述

## 1.1 第一个C语言程序：Hello world!

C 语言的源代码文件是一个普通的文本文件，但扩展名必须是.c。

```c
//std：standard标准  i：input输入（从键盘获取信息）  
//o：output输出（向屏幕打印信息）  h：header头文件
#include<stdio.h>    //包含标准输入输出头文件
#include<stdlib.h>    //system函数的头文件

//int：函数的返回值类型
//main：程序的主函数（程序的入口函数），必须要有这个主函数（有且仅有一个）
//()参数列表
//{}函数的实现体
//	printf("hello word!\n");向屏幕上输出hello world
//  return 0;返回正常的退出结果
int main()
{
	//相当于在gcc中执行代码，在gcc中执行“”里面的代码能取到一样的效果
	//system函数的作用：以字符串的方式执行系统命令
	system("mspaint");//打开画图工具
	system("notepad");//打开记事本
	system("calc");//打开计算器
	system("ping www.baidu.com");//检查是否可以上网
	system("pause");//暂停（起阻塞作用）  在程序中会输出 请按任意键继续
	//一般用在return之前，把窗口停在原地，否则窗口出来就没了，看不到

	//printf("hello word!\n");
	return 0;
}
```

### 1.1.1 代码分析

#### （1）#include头文件包含

1）#include <  >  表示包含系统库函数对应的头文件

2）#include"  "     表示包含自定义的头文件

```C
//std：standard标准  i：input输入（从键盘获取信息）  
//o：output输出（向屏幕打印信息）  h：header头文件
#include<stdio.h>         //包含标准输入输出头文件
#include<stdlib.h>        //system函数的头文件
#include"Managnment"      //包含自定义头文件
```

#### （2）main函数

main 函数是 C 语言程序的入口，程序是从 main 函数开始执行，main函数有且仅有一个。

#### （3）注释

1）// 代表行注释

2）/*    */ 代表块注释，即多行注释

#### （4）`printf`函数

`printf`是 C 语言库函数，功能是向标准输出设备输出一个字符串

```
printf(“hello world\n”);    //  \n 的意思是回车换行
```

#### （5）`return`语句

1）`return` 代表函数执行完毕，返回 return 代表函数的终止。

2）如果 main 定义的时候前面是 int，那么 return 后面就需要写一个整数；如 果 main 定义的时候前面是 void，那么 return 后面什么也不需要写。

3）在 main 函数中 return 0 代表程序执行成功，return -1 代表程序执行失败。

4） int main()和 void main()在 C 语言中是一样的，但 C++只接受 int main 这种定义方式

```c
#include <stdio.h>
int main()
{
    printf("hello world\n");
    return 0;
}
```

### 1.1.2 `system`函数

```c
#include <stdlib.h>
int system(const char *command);
```

功能：在已经运行的程序中执行另外一个外部程序
参数：外部可执行程序名字
返回值：
		成功：不同系统返回值不一样
		失败：通常是 - 1

记住：用system函数一定要包含`#include<stdlib.h>`头文件

```c
//记住：用system函数一定要包含`#include<stdlib.h>`头文件

//相当于在gcc中执行代码，在gcc中执行“”里面的代码能取到一样的效果
//system函数的作用：以字符串的方式执行系统命令
system("mspaint");//打开画图工具
system("notepad");//打开记事本
system("calc");//打开计算器
system("ping www.baidu.com");//检查是否可以上网
system("pause");//暂停（起阻塞作用）  在程序中会输出 请按任意键继续
//一般用在return之前，把窗口停在原地，否则窗口出来就没了，看不到
```



## 1.2 通过`gcc`编译C代码

C 代码编译成可执行程序经过 4 步： 

1）预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删 除，这里并不会检查语法

2）编译：检查语法，将预处理后文件编译生成汇编文件 

3）汇编：将汇编文件生成目标文件(二进制文件) 

4）链接：C 语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接 到最终的可执行程序中去

```C++
//gcc分布式编译：产生4个文件
gcc hello.c -E hello.i       //预处理阶段代码，生成.i文件
gcc hello.i -S hello.s       //编译阶段代码，生成.s文件
gcc hello.s -c hello.o       //汇编阶段代码，生成.o文件
gcc hello.o -o hello.exe     //链接阶段代码，生成.exe文件
    
//gcc一步编译
gcc hello.c -o hello.exe     //直接生成.exe文件
```

各阶段所起的作用如下图所示：

![用gcc分布式编译1](E:\HUST\The future\后端学习\C\C学习代码（手敲）\01 用gcc分布式编译\用gcc分布式编译1.png)

## 1.3 寄存器、缓存、内存三者关系

1）CPU 计算时，先预先把要用的数据从硬盘读到内存，然后再把即将要用的数据读到寄存器。于是 CPU<--->寄存器<--->内存，这就是它们之间的信息交换。那为什么有缓存呢？因为如果老是操作内存中的同一址地的数据，就会影响速度。于是就在寄存器与内存之间设置一个缓存。 因为从缓存提取的速度远高于内存。当然缓存的价格肯定远远高于内存，不然的话，机器里就没有内存的存在。 

==2）====从远近来看：CPU<--->寄存器<---> 缓存 <---> 内存==

![2.9 CPU与寄存器](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.9 CPU与寄存器.png)

## 1.4 Visual Studio中常用快捷键

```c
//常用快捷键
//F5 调试运行
//ctrl+shift+b 编译代码（但不会运行）
//ctrl+k+f 自动格式化代码
//ctrl+k+c 注释代码
//ctrl+k+u 取消注释
//F9 添加断点 取消断点
//F11 逐语句
//F10 逐过程
//shift+F11 跳出 将函数体中未执行的内容执行
```

## 1.5 C4996错误处理

vs中不建议用一些传统的c语言库函数,`scanf、sprintf`，因此报出c4996错误。解决办法有3个：

```c
//第一种调试方法c4996错误：引用宏
#define _CRT_SECURE_NO_WARNINGS

//第二种调试方法c4996错误：加一行代码
#pragma warning(disable:4996)

//第三种调试方法c4996错误：右键项目->属性 配置属性 预处理器 预处理定义 编辑
#include<stdio.h>
#include<stdlib.h>
int main()
{
	//vs中不建议用一些传统的c语言库函数,scanf、sprintf，报出c4996错误
	char buf[1024] = { 0 };
	sprintf(buf, "%s", "hello word");
	printf("%s", buf);

	system("pause");
	return 0;
}
```

## 1.6 命令行参数==argv==

```c
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

//argc 命令行变量数量
// argv 命令行参数
int main(int argc ,char* argv[])
{
	printf("命令行变量的数量：%d\n", argc);

	//如果我的命令大于1条，分别把所有命令输出到屏幕中
	//在gcc中实现
	if (argc > 1)
	{
		int i = 0;
		for (i = 0; i < argc; i++)
		{
			printf("%s\n", argv[i]);
		}
	}
	system("pause");
	return EXIT_SUCCESS;
}
```

## 1.8 CPU与寄存器

![2.9 CPU与寄存器](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.9 CPU与寄存器.png)

## 1.9 内存的最小存储单位

![2.10 内存最小存储单位](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.10 内存最小存储单位.png)

# 2 数据类型

## 2.1 变量

### 2.1.1 变量的基本意义

```c
//语法：数据类型 变量名 = 变量初始值
//可以在程序中改变的值
void test01()
{
	int a = 10;	
	printf("a=%d\n", a);// %d作占位用（占整型）,a填补这个位置，\n表示换行
	a = 20;//重新给变量赋值
}
```

### 2.1.2 变量的定义和声明

1、变量的定义

==建议创建变量时就给一个初始值，默认给0，如果不给变量初始值，这个值是随机的，而且vs下不可以访问==

```c
//定义：创建变量的时候给初始值
void test01()
{
	//建议创建变量时就给一个初始值，默认给0
	int a = 100;
	printf("a=%d\n", a);
    
	int b;//如果不给变量初始值，这个值是随机的，而且vs下不可以访问
	//printf("a=%d\n", b);
}
```

2、变量的声明：

（1）如果变量的定义在变量的==使用前==，属于自动声明。

（2）如果变量的定义在变量的==使用后==，需要显示声明，加关键字extern，告诉编译器g_a的定义在后面，如果提前使用了，不要报错。

```c
//变量的声明
//如果变量的定义在变量的使用前，属于自动声明
void test02()
{
	//如果变量的定义在变量的使用后，需要显示声明，加关键字extern
	extern int g_a;//告诉编译器g_a的定义在后面，如果提前使用了，不要报错
	printf("g_a=%d\n", g_a);//不在上面用extern显示声明会报错，加了之后可以解决这个问题
}
int g_a = 100;
```

## 2.2 常量

程序运行期间不可以修改的值。

常量的五种形式：数值常量、字符常量、字符串常量、符号常量（宏常量）、const修饰的变量。

```c
#define DAY 7
void test01()
{
	//1、数值常量  100 200(整数型常量) 3.14 1.1(实数型常量)
	//100=200;

	//2、字符常量 'a' 'b' 'c' '\n' '\\'
	//'a'='b';

	//3、字符串常量
	//"hello world" = "aaaa";

	//4、符号常量（宏常量）
	printf("一周共有%d天\n", DAY);
	//DAY = 14;

	//5、const修饰的变量
	const int month = 12;
	//month = 24;//不能改变这个值，const修饰后,month也属于常量
	printf("一年一共有%d月\n", month);
}
```

## 2.3 关键字和标识符的命名规则

标识符的命名规则(创建变量名的规范)：
1、标识符不可以是关键字。
2、标识符只能由字母、数字、下划线组成。
3、第一个字符必须是字母、数字或者下划线。
4、标识符的字母是区分大小写的。

==标识符命名虽好做到见名知意==

```c
void test02()
{
	int a = 10;
	//int extern = 10;
	int abc123 = 10;
	//int 123abc = 10;
	int a_b1 = 10;
	int _ab123;
	//int 123_abc;
	//printf("a=%d\n", A);//字母是区分大小写的

	//标识符命名虽好做到见名知意
}
```

## 2.4 数据类型

### 2.4.1 整型

| **数据类型**        | **占用空间**                                    |
| ------------------- | ----------------------------------------------- |
| short(短整型)       | 2字节                                           |
| int(整型)           | 4字节                                           |
| long(长整形)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) |
| long long(长长整形) | 8字节                                           |

#### 2.4.1.1 整型的定义和输出

当一个小的数据类型赋值给一个大的数据类型，不会出错，因为编译器会自动转化。但当一个大的类型赋值给一个小的数据类型，那么就可能丢失高位。

| **整型常量** | **所需类型**               |
| ------------ | -------------------------- |
| 10           | 代表int类型                |
| 10l, 10L     | 代表long类型               |
| 10ll, 10LL   | 代表long long类型          |
| 10u, 10U     | 代表unsigned int类型       |
| 10ul, 10UL   | 代表unsigned long类型      |
| 10ull, 10ULL | 代表unsigned long long类型 |

==打印输出时，要注意占位符类型==

| **打印格式** | **含义**                   |
| ------------ | -------------------------- |
| %hd          | 输出short类型              |
| %d           | 输出int类型                |
| %ld          | 输出long类型               |
| %lld         | 输出long long类型          |
| %hu          | 输出unsigned short类型     |
| %u           | 输出unsigned int类型       |
| %lu          | 输出unsigned long类型      |
| %llu         | 输出unsigned long long类型 |

==（1）定义有符号的变量：int前面隐藏加了关键字signed==

（2）定义无符号的变量：unsigned int

```c
void test01()
{
	short num1 = 10;//短整型  -2^15~2^15-1
	int num2 = 10;//整型  -2^31~2^31-1
	long num3 = 10;//长整型 
	long long num4 = 10;//长长整型

	//输出时，要注意占位符类型
	printf("num1=%hd\n", num1);//用%hd打印
	printf("num2=%d\n", num2);//用%d打印
	printf("num3=%ld\n", num3);//用%ld打印
	printf("num4=%lld\n", num4);//用%lld打印

	//上述中，最常用的是整型 int
}
```

```c
//1、无符号和有符号整型  常量
void test01()
{
	//有符号的int类型的常量
	printf("%d\n", 10);

	//无符号的int类型的常量
	printf("%u\n", 10U);//用%u作占位符，后面的U课不用

	//有符号的long 类型的常量
	printf("%ld\n", 10L);
    
	//无符号的long类型的常量
	printf("%lu\n", 10UL);
}

//2、无符号和有符号整型  变量
void test02()
{
	//定义有符号的变量
	int a = 10;//int前面隐藏加了关键字signed
	printf("%d\n", a);

	//定义无符号的变量
	unsigned int b = 10;
	printf("%u\n", b);
}
```

#### 2.4.1.2 sizeof关键字

sizeof 统计  一个变量   或者   一个数据类型   ==占用内存空间大小==
语法：sizeof(类型/变量)

| **数据类型**        | **占用空间**                                    |
| ------------------- | ----------------------------------------------- |
| short(短整型)       | 2字节                                           |
| int(整型)           | 4字节                                           |
| long(长整形)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) |
| long long(长长整形) | 8字节                                           |

```c
void test01()
{
	printf("int的类型大小为：%d\n", sizeof(int));//4
	printf("int的类型大小为：%d\n", sizeof(short));//2
	printf("int的类型大小为：%d\n", sizeof(long));//4
	printf("int的类型大小为：%d\n", sizeof(long long));//8

	int a = 10;
	printf("a的类型大小为：%d\n", sizeof(a));//4
}
```

### 2.4.2 字符型

#### 2.4.2.1 字符变量的定义与输出

==字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的 ASCII 编码放到变量的存储单元中。==

==char的本质就是一个1字节大小的整型。即小整型==

* 用途：字符型主要是==显示单个字符==

* 语法：char ch = 'a';

* 注意事项：创建字符型变量时==不要用双引号，用单引号==

* 单引号里面 只能有一个字符，不要有字符串，一个字符可以是转义字符  如：\n

==字符型变量输出时：用%c进行占位==

```c
void test01()
{
	char ch = 'a';
	printf("ch=%c\n", ch);

	printf("char占用内存空间大小为：%d\n", sizeof(char));//一个字节 0~255
	
	//ch = 'bcdf';//会报错，只能 用单引号，里面单个字符
	//ch = "bcdf";//会报错，只能 用单引号，里面单个字符
	//printf("ch=%c\n", ch);

	//计算机中存放的内容是0和1，针对于字符该如何进行存储呢？
	//每个字符都对应一个特定的数值，字符和数字建立一一的对应，将数字存放在计算机中
	//为了维护字符和数字的关系，建立了一个表格，ASCII码表（美国信息交换标准代码）
	//常用的ASCII编码：'0':48  'a':97   'A':65

	//char类型也称为小整型
	printf("ch编码：%d\n", ch);
	ch = 98;
	printf("ch=%c\n", ch);//ch=b
}
```

#### 2.4.2.2 字符变量的大小写转换

==小写->大写：减32==

==大写->小写：加32==

```c
//大小写转换
void test02()
{
	char ch1 = 'a';
	printf("转换前ch1：%c\n", ch1);

	ch1 -= 32;

	printf("转换后ch2：%c\n", ch1);

	char ch2 = 'Z';
	printf("转换前ch2：%c\n", ch2);
	ch2 += 32;
	printf("转换后ch2：%c\n", ch2);
}
```

#### 2.4.2.3 ASCII码表

计算机中存放的内容是0和1，针对于字符该如何进行存储呢？

==每个字符都对应一个特定的数值，字符和数字建立一一的对应，将数字存放在计算机中==

==为了维护字符和数字的关系，建立了一个表格，ASCII码表（美国信息交换标准代码）==

常用的ASCII编码：=='0':48  'a':97   'A':65==

![2.18 ASCII码表](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.18 ASCII码表.jpg)

#### 2.4.2.4 转义字符

| **转义字符** | **含义**                                | **ASCII码值（十进制）** |
| ------------ | --------------------------------------- | ----------------------- |
| ==\a==       | ==警报==                                | 007                     |
| ==\b==       | ==退格(BS) ，将当前位置移到前一列==     | 008                     |
| ==\f==       | ==换页(FF)，将当前位置移到下页开头==    | 012                     |
| ==\n==       | ==换行(LF) ，将当前位置移到下一行开头== | 010                     |
| ==\r==       | ==回车(CR) ，将当前位置移到本行开头==   | 013                     |
| ==\t==       | ==水平制表(HT) （跳到下一个TAB位置）==  | 009                     |
| ==\v==       | ==垂直制表(VT)==                        | 011                     |
| \\           | 代表一个反斜线字符"\"                   | 092                     |
| \'           | 代表一个单引号（撇号）字符              | 039                     |
| \"           | 代表一个双引号字符                      | 034                     |
| \?           | 代表一个问号                            | 063                     |
| \0           | 数字0                                   | 000                     |
| \ddd         | 8进制转义字符，d范围0~7                 | 3位8进制                |
| \xhh         | 16进制转义字符，h范围0-9，a-f，A-F      | 3位16进制               |

```c
printf("hello\n");		//  \n换行
printf("abc\rdef");		//  \r将输出光标移到本行开头
printf("\\");			//  \\输出一个\

printf("abc\tdef");		//  \t表示Tab键（水平制表符）
printf("\a");			//  警报声
printf("%%");			//  %%输出一个%
```

#### 2.4.2.5 数值溢出

当超过一个数据类型能够存放最大的范围时，数值会溢出。

==有符号位最高位溢出的区别：==

==（1）符号位溢出会导致数的正负发生改变。==

==（2）最高位的溢出会导致最高位丢失。==

==变量通过运算之后是补码，要想对其进行输出，需要将该补码转换成原码，再进行输出。==

```c
char ch;

//1、符号位溢出会导致数的正负发生改变
ch = 0x7f + 2; //127+2
printf("%d\n", ch);
//	0111 1111
//+2后 1000 0001，这是负数补码，其原码为 1111 1111，结果为-127
```

| **数据类型**  | **占用空间** | **取值范围**             |
| ------------- | ------------ | ------------------------ |
| char          | 1字节        | -128到 127(-2^7 ~ 2^7-1) |
| unsigned char | 1字节        | 0 到 255(0 ~ 2^8-1)      |

```c
char ch;

//1、符号位溢出会导致数的正负发生改变
ch = 0x7f + 2; //127+2
printf("%d\n", ch);
//	0111 1111
//+2后 1000 0001，这是负数补码，其原码为 1111 1111，结果为-127

//2、最高位的溢出会导致最高位丢失
unsigned char ch2;
ch2 = 0xff+1; //255+1
printf("%u\n", ch2);
//	  1111 1111
//+1后 10000 0000， char只有8位最高位的溢出，结果为0000 0000，十进制为0

ch2 = 0xff + 2; //255+2
printf("%u\n", ch2);
//	  1111 1111
//+2后 10000 0001， char只有8位最高位的溢出，结果为0000 0001，十进制为1

return 0;
```

###  2.4.3 字符串型

#### 2.4.3.1 字符串常量

* ==字符串型常量输出时：用%s进行占位，%s输出的时候，遇到\0结束==
* 字符串以\0结尾，双引号引起的字符串会自带字符串结束的标志\0
* ==计算字符串时，需要计算：字符+空格+结束标识符\0==
* %s输出字符字符串的时候 需要两个内容，从哪开始输出，输出到哪
* ==" "会返回字符串中第一个字符的地址==

```c
void test01()
{
	printf("%s", "hello world");//用%s进行占位，string
	
	//双引号引起的字符串会自带字符串结束的标志\0
	printf("sizeof=%d\n", sizeof("hello world"));//12 有一个空格，还有一个结束标识符

	//%s输出字符字符串的时候 需要两个内容，从哪开始输出，输出到哪
	//""会返回字符串中第一个字符的地址
	//%s输出的时候 遇到\0结束
	printf("%s\n", "hello\0world");
	printf("%s\n", "\0hello world");
}
```

#### 2.4.3.2 字符串变量

==字符串型变量输出时：用%s进行占位==

```c
void test02()
{
	//字符数组 -> 字符串
	char str[] = "hello world";
	printf("sizeof=%d\n", sizeof(str));

	str[0] = 'x';
	printf("%s\n", str);

	//后面课程中会讲字符串的一些处理函数
}
```

#### 2.4.3.3 字符和字符串所占字节大小

* ==字符：如'a'，只占一个字节==

* ==字符串：如"hello world"，除了所能看到的字符，还包含一个结束标记符\0==

```c
void test03()
{
	char a1 = 'a';//a1属于字符  占一个字节
	char a2[] = "a";//a2属于字符串  占两个字节

}
```

#### 2.4.3.4 字符串格式化输入和输出

#####  （1）printf 函数和 putchar 函数

* **printf**是输出一个字符串，**putchar**输出一个char。

* **printf格式字符**：

| **打印格式** | **对应数据类型** | **含义**                                                     |
| ------------ | ---------------- | ------------------------------------------------------------ |
| %d           | int              | 接受整数值并将它表示为有符号的十进制整数                     |
| %hd          | short int        | 短整数                                                       |
| %hu          | unsigned short   | 无符号短整数                                                 |
| %o           | unsigned int     | 无符号8进制整数                                              |
| %u           | unsigned int     | 无符号10进制整数                                             |
| %x,%X        | unsigned int     | 无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF           |
| %f           | float            | 单精度浮点数                                                 |
| %lf          | double           | 双精度浮点数                                                 |
| %e,%E        | double           | 科学计数法表示的数，此处"e"的大小写代表在输出时用的"e"的大小写 |
| %c           | char             | 字符型。可以把输入的数字按照ASCII码相应转换为对应的字符      |
| %s           | char *           | 字符串。输出字符串中的字符直至字符串中的空字符（字符串以'\0‘结尾，这个'\0'即空字符） |
| %p           | void *           | 以16进制形式输出指针                                         |
| %%           | %                | 输出一个百分号                                               |

* **printf附加格式**：

| **字符**          | **含义**                                                     |
| ----------------- | ------------------------------------------------------------ |
| l(字母l)          | 附加在d,u,x,o前面，表示长整数                                |
| -                 | 左对齐                                                       |
| m(代表一个整数)   | 数据最小宽度                                                 |
| 0(数字0)          | 将输出的前面补上0直到占满指定列宽为止不可以搭配使用-         |
| m.n(代表一个整数) | m指域宽，即对应的输出项在输出设备上所占的字符数。n指精度，用于说明输出的实型数的小数位数。对数值型的来说，未指定n时，隐含的精度为n=6位。 |

```c
	int a = 100;
	printf("a = %d\n", a);//输出100
	printf("%p\n", &a);//以16进制形式输出指针，即输出地址
	printf("%%d\n");//输出%d

	char c = 'a';
	putchar(c);//输出a，putchar只有一个参数，就是要输出的char
	long a2 = 100;
	printf("%ld, %lx, %lo\n", a2, a2, a2);//输出长整数十进制、十六进制、八进制：100，64，144

	long long a3 = 1000;
	printf("%lld, %llx, %llo\n", a3, a3, a3);//输出长长整数十进制、十六进制、八进制：1000，3e8，1750

	int abc = 10;
	printf("abc = '%6d'\n", abc);//abc = '    10'，右对齐，数据最小宽度为6，其余用空格补齐
	printf("abc = '%-6d'\n", abc);//abc = '10    '，左对齐，数据最小宽度为6，其余用空格补齐
	printf("abc = '%06d'\n", abc);//abc = '000010'，右对齐，数据最小宽度为6，其余用0补齐
	printf("abc = '%-06d'\n", abc);//abc = '10    '，左对齐，数据最小宽度为6，其余用空格补齐

	double d = 12.3;
	printf("d = \' %-10.3lf \'\n", d);//d = ' 12.300     '，左对齐，输出数据宽度为10，小数位数为3，其余用空格补齐
```

##### （2）scanf 函数和 getchar 函数

* scanf通过%转义的方式可以得到用户通过标准输入设备输入的数据，==第二个参数一定是变量的地址，而不是变量名。==
* getchar是从标准输入设备读取一个char，换行符\n也可以读取。

```c
	char ch1;
	char ch2;
	char ch3;
	int a;
	int b;

	printf("请输入ch1的字符：");
	ch1 = getchar();
	printf("ch1 = %c\n", ch1);
	
	//从缓冲区中获取一个字符（相当于把第一次输入的那个换行符\n取走了）
	//防止这个换行符被下一个输入取走，使程序提前退出，不能进行下一次输入
	
	getchar(); //从缓冲区中获取一个字符，取走第一次输入的那个\n符

	printf("请输入ch2的字符：");
	ch2 = getchar();
	printf("\'ch2 = %ctest\'\n", ch2);

	//从缓冲区中获取一个字符（相当于把第一次输入的那个换行符\n取走了）
	//防止这个换行符被下一个输入取走，使程序提前退出，不能进行下一次输入
	getchar(); //从缓冲区中获取一个字符，取走第一次输入的那个\n符

	printf("请输入ch3的字符：");
	scanf("%c", &ch3);//这里第二个参数一定是变量的地址，而不是变量名
	printf("ch3 = %c\n", ch3);

	printf("请输入a的值：");
	scanf("%d", &a);
	printf("a = %d\n", a);

	printf("请输入b的值：");
	scanf("%d", &b);
	printf("b = %d\n", b);

	return 0;
```

##### （3）数据的输入（scanf 和 getchar）

用 scanf 函数实现数据的输入

==用 putchar 函数实现数据的输入，但是只输入一个字符==

* 1、整型数据的输入

```c
void test01()
{
	int num = 0;
	printf("请重新给num进行赋值：\n");
	scanf("%d", &num);//&表示取变量地址
	printf("num的新值：%d\n",num);
}
```

* 2、字符型数据的输入

```c
void test02()
{
	char ch = 'a';
	printf("请重新给ch进行赋值：\n");
	scanf("%c", &ch);//&表示取变量地址
	printf("ch的新值：%c\n", ch);
}
```

* 3、浮点型数据的输入

```c
void test03()
{
	double d = 3.14;
	printf("请重新给d进行赋值：\n");
	scanf("%lf", &d);//&表示取变量地址
	printf("ch的新值：%lf\n", d);
	printf("ch的新值：%.4lf\n", d);
}
```

* 4、字符串型数据的输入

```c
void test04()
{
	char str[64] = "";
	printf("请重新给str进行赋值：\n");
	scanf("%s", str);//数组名str表示数组的首地址
	printf("str的新值：%s\n", str);
}
```

* 5、==注意事项：两个 scanf 函数之间要加一个 getchar() 函数，从缓冲区取走上次输入时所输入的换行符\n。防止后面报错==

```c
void test05()
{
	int num = 0;
	printf("请重新给num进行赋值：\n");
	scanf("%d", &num);//&表示取变量地址
	printf("num的新值：%d\n", num);

	//从缓冲区中获取一个字符（相当于把第一次输入的那个换行符\n取走了）
	//防止这个换行符被下一个输入取走，使程序提前退出，不能进行下一次输入
	getchar();//从缓冲区中获取一个字符

	char ch = 'a';
	printf("请重新给ch进行赋值：\n");
	scanf("%c", &ch);//&表示取变量地址
	printf("ch的新值：%c\n", ch);

	//putchar('a');//向屏幕上输出一个字符，使用场景少
}

```

##### （4）数据的输出（printf 和 putchar）

* 1、printf输出各个进制

```c
void test01()
{
	int num = 10;
	printf("十进制结果：%d\n", num);//10，十进制
	printf("八进制结果：%#o\n", num);//012，八进制，占位符用%o ~ 12  用%#o ~ 012
	printf("十六进制结果：%#x\n", num);//0xa，十六进制，占位符用%x ~ a  用%#x ~ 0xa
	printf("十六进制结果：%#X\n", num);//0XA，十六进制，占位符用%X ~ A  用%#x ~ 0XA
}
```

* 2、在程序中自己写各种进制

```c
void test02()
{
	int a = 123;//十进制
	int b = 0123;//八进制
	int c = 0xabc;//十六进制
	printf("a=%d\n", a);//123，输出十进制
	printf("a=%#o\n", a);//0173，输出八进制
	printf("a=%#x\n", a);//0x7b，输出十六进制
}
```

* 3、其他扩展

```c
//其他扩展
void test03()
{
	//%nd  预留n个宽度  数字右对齐
	printf("##%5d##\n", 123);//##  123##
	printf("##%2d##\n", 123);//##123##，以数字为准，如果宽度不足，正常输出数字
	printf("##%05d##\n", 123);//##00123##，用0填补空位
	printf("##%-5d##\n", 123);//##123  ##，数字左对齐
	//注意事项：负号和0不可以同时使用
	printf("##%-05d##\n", 123);//##123  ##，如果可以共存，那么结果位12300会产生误解，0会自动失效
}
```

### 2.4.4 浮点型

| **数据类型** | **占用空间** | **有效数字范围** |
| ------------ | ------------ | ---------------- |
| float        | 4字节        | 7位有效数字      |
| double       | 8字节        | 15～16位有效数字 |

#### 2.4.4.1 浮点型常量

默认将小数常量认为是double型，要想变成float型，需要在小数后面加f

```c
void test01()
{
	printf("sizeof 3.14 = %d\n", sizeof(3.14));//默认将小数认为是double型
	printf("sizeof 3.14 = %d\n", sizeof(3.14f));//要变成float型，在小数后面加f
}
```

#### 2.4.4.2 浮点型变量

float和double的区别：double的精确位数要更大

输出时：

| **打印格式** | **含义**                         |
| ------------ | -------------------------------- |
| %f           | 输出float类型，默认保留六位小数  |
| %.2f         | 输出float类型，保留2位小数       |
| %lf          | 输出double类型，默认保留六位小数 |
| %.2lf        | 输出double类型，保留2位小数      |

```c
void test02()
{
	float a = 3.14f;//float型
	printf("a=%f\n", a);//%f  用printf输出时默认为保留6个小数
	printf("a=%.2f\n", a);//.2f代表保留两位小数
	
	double b = 3.1415;
	printf("b=%lf\n", b);//%lf  默认保留六位小数
	printf("b=%.3lf\n", b);//.3lf代表保留三位小数（四舍五入）

	//float和double的区别：double的精确位数要更大
	float PI1 = 3.14159265358;
	printf("PI1=%.10f\n", PI1);

	double PI2 = 3.14159265358;
	printf("PI2=%.10f\n", PI2);
}
```

#### 2.4.4.3  浮点型数据存储（提高）

![2.20 浮点型数据存储(提高)](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.20 浮点型数据存储(提高).png)

### 2.4.5 进制

#### 2.4.5.1 进制的基本概念

X进制，就表示某一位置上的数运算时是逢X进一位

| **十进制** | **二进制** | **八进制** | **十六进制** |
| ---------- | ---------- | ---------- | ------------ |
| 0          | 0          | 0          | 0            |
| 1          | 1          | 1          | 1            |
| 2          | 10         | 2          | 2            |
| 3          | 11         | 3          | 3            |
| 4          | 100        | 4          | 4            |
| 5          | 101        | 5          | 5            |
| 6          | 110        | 6          | 6            |
| 7          | 111        | 7          | 7            |
| 8          | 1000       | 10         | 8            |
| 9          | 1001       | 11         | 9            |
| 10         | 1010       | 12         | A            |
| 11         | 1011       | 13         | B            |
| 12         | 1100       | 14         | C            |
| 13         | 1101       | 15         | D            |
| 14         | 1110       | 16         | E            |
| 15         | 1111       | 17         | F            |
| 16         | 10000      | 20         | 10           |

![2.23 进制的基本概念](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.23 进制的基本概念.png)

#### 2.4.5.2 十进制转二、八、十六进制

利用==短除法==进行转换

![2.24 十进制转二、八、十六进制](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.24 十进制转二、八、十六进制.png)

#### 2.4.5.3 二、八、十六进制转十进制

利用==权值法==进行转换

![2.25 二、八、十六进制转十进制](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.25 二、八、十六进制转十进制.png)

#### 2.4.5.4 二进制转八、十六进制

==二进制转八进制：将二进制从右向左，每3位组成一个八进制。==

==二进制转十六进制：将二进制从右向左，每4位组成十六进制数字。==

![2.26 二进制转八、十六进制](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.26 二进制转八、十六进制.png)

#### 2.4.5.5 八、十六进制转二进制

==八进制转二进制：八进制从右向左，每一个八进制组成3位二进制。==

==十六进制转二进制：十六进制从右向左，每一个十六进制组成4位二进制。==

![2.27 八、十六进制转二进制](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.27 八、十六进制转二进制.png)

### 2.4.6 计算机数据的存储：原码、反码、补码

#### 2.4.6.1 计算机存数据

存数据：

**==计算机一律用补码的形式存数据==**

==（1）如果是无符号：原码=反码=补码==

==（2）如果是有符号：==

​			==1）正数：原码=反码=补码==

​			==2）负数：补码=反码+1==

![2.29 数据存储方式(存数据)](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.29 数据存储方式(存数据).png)

#### 2.4.6.2 计算机取数据

取数据：

==（1）无符号取数据：怎么存的怎么取，八进制和十六进制，不用考虑正负。==

==（2）有符号取数据：==

​			==1）如果符号位为0（正数）：原码=反码=补码，原样取出==

​			==2）如果符号位为1（负数）：符号位不动，其余位取反+1==

![2.30 数据存储方式(取数据)](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.30 数据存储方式(取数据).png)

#### 2.4.6.3 补码的意义

==**在计算机系统中，数值一律用补码来存储**==，原因是：

* ==1、**统一了零的编码**==

示例1：用8位二进制数分别表示+0和-0

| **十进制数** | **原码**  |
| ------------ | --------- |
| +0           | 0000 0000 |
| -0           | 1000 0000 |

| **十进制数** | **反码**  |
| ------------ | --------- |
| +0           | 0000 0000 |
| -0           | 1111 1111 |

不管以原码方式存储，还是以反码方式存储，0也有两种表示形式。为什么同样一个0有两种不同的表示方法呢？

但是如果以补码方式存储，补码统一了零的编码：

| **十进制数** | **补码**                                              |
| ------------ | ----------------------------------------------------- |
| +0           | 0000 0000                                             |
| -0           | 10000 0000由于只用8位描述，最高位1丢弃，变为0000 0000 |

* 2、**==将减法运算转变为加法运算==**，两个用补码表示的数相加时，如果最高位(符号位)有进位，则进位被舍弃。

示例2：计算9-6的结果

（1）**以原码方式相加**：

| **十进制数** | **原码**  |
| ------------ | --------- |
| 9            | 0000 1001 |
| -6           | 1000 0110 |

![img](file:///C:\Users\wenca\AppData\Local\Temp\ksohtml\wps9CEE.tmp.jpg)

结果为-15，不正确。

（2）**以补码方式相加**：

| **十进制数** | **补码**  |
| ------------ | --------- |
| 9            | 0000 1001 |
| -6           | 1111 1010 |

![img](file:///C:\Users\wenca\AppData\Local\Temp\ksohtml\wps1883.tmp.jpg)

最高位的1溢出，剩余8位二进制表示的是3，正确。

### 2.4.7 类型限定符（extern、const、volatile、register）

| **限定符** | **含义**                                                     |
| ---------- | ------------------------------------------------------------ |
| extern     | 声明一个变量，extern声明的变量没有建立存储空间。extern int a; |
| const      | 定义一个常量，常量的值不能修改。const int a = 10;            |
| volatile   | 防止编译器优化代码                                           |
| register   | 定义寄存器变量，提高效率。register是建议型的指令，而不是命令型的指令，如果CPU有空闲寄存器，那么register就生效，如果没有空闲寄存器，那么register无效。 |

```c
//1、extern
void test01()
{
	//变量的声明，在声明的时候，并没有给变量分配空间，不可以初始化
	extern int g_a;
	printf("g_a=%d\n", g_a);
}
int g_a = 100;

//2、const
void test02()
{
	const int num = 20;
	//num=20;//不可以修改
}

//3、volatile  防止编译器优化代码
void test03()
{
	//不加volatile的话编译器会直接优化代码使num=60，前面的代码不会执行
	volatile int num = 10;
	num = 10;
	num = 20;
	num = 30;
	num = 40;
	num = 50;
	num = 60;
}

//4、register 寄存器变量 讲数字放入到寄存器中，如果有空闲寄存器，就放入，如果没有，放入失败
//加载到内存上。频繁使用的变量，可以将变量放入到寄存器中
//寄存器变量 由于可能加载成功，因此不可以进行取地址的操作
void test04()
{
	register int num = 10;
	//printf("%d\n", &num);//编译器不允许对记清楚变量取地址
	printf("%d\n", num);
}
```

# 3 运算符与表达式

## 3.1 常用运算符分类

| **运算符类型** | **作用**                               |
| -------------- | -------------------------------------- |
| 算术运算符     | 用于处理四则运算                       |
| 赋值运算符     | 用于将表达式的值赋给变量               |
| 比较运算符     | 用于表达式的比较，并返回一个真值或假值 |
| 逻辑运算符     | 用于根据表达式的值返回真值或假值       |
| 位运算符       | 用于处理数据的位运算                   |
| sizeof运算符   | 用于求字节数长度                       |

## 3.2 算术运算符

| **运算符** | **术语**   | **示例**    | **结果**  |
| ---------- | ---------- | ----------- | --------- |
| +          | 正号       | +3          | 3         |
| -          | 负号       | -3          | -3        |
| +          | 加         | 10 + 5      | 15        |
| -          | 减         | 10 - 5      | 5         |
| *          | 乘         | 10 * 5      | 50        |
| /          | 除         | 10 / 5      | 2         |
| %          | 取模(取余) | 10 % 3      | 1         |
| ++         | 前自增     | a=2; b=++a; | a=3; b=3; |
| ++         | 后自增     | a=2; b=a++; | a=3; b=2; |
| --         | 前自减     | a=2; b=--a; | a=1; b=1; |
| --         | 后自减     | a=2; b=a--; | a=1; b=2; |

1、**算术运算符**

* 除数不可以是0
* ==两个小数可以进行除法运算==

```c
//1、算术运算符
void test01()
{
	int num1 = 10;
	int num2 = 3;

	printf("num1+num2=%d\n", num1 + num2);//13
	printf("num1-num2=%d\n", num1 - num2);//7
	printf("num1*num2=%d\n", num1 * num2);//30
	printf("num1/num2=%d\n", num1 / num2);//3  两个整型进行除法运算，结果依然是整型（舍弃小数）
}

void test02()
{
	int num1 = 10;
	int num2 = 20;
	printf("num1/num2=%d\n", num1 / num2);

	num1 = 10;
	num2 = 0;
	//printf("num1/num2=%d\n", num1 / num2);//除数不可以为0
	
	//两个小数可以进行除法运算
	double d1 = 0.5;
	double d2 = 0.25;

	//两个小数可以进行除法运算
	printf("d1/d2=%lf\n", d1 / d2);//2.000000
}
```

2、**取模运算符**

* 输出%时，前面要加两个%才可以
* ==两个小数不可以进行取模运算==

```c
//2、取模运算
void test03()
{
	int num1 = 10;
	int num2 = 3;
	printf("num1%%num2=%d\n", num1 % num2);//前面要加两个%才能输出一个%

	num1 = 10;
	num2 = 20;
	printf("num1%%num2=%d\n", num1 % num2);

	num1 = 10;
	num2 = 0;
	//printf("num1%%num2=%d\n", num1 % num2);//除数不可以为0

	//两个小数不可以进行取模运算
	double d1 = 1.1;
	double d2 = 2.2;
	//printf("d1%%d2=%lf", d1 % d2);
}

//案例练习
void test04()
{
	int num1 = 5678;
	printf("千位=%d\n", num1 / 1000);
	printf("百位=%d\n", num1 % 1000 / 100);
	printf("十位=%d\n", num1 % 100 / 10);
	printf("个位=%d\n", num1 % 10);
}
```

3、**自增、自减运算符**

* ==前置：先对变量本身进行++运算，再计算表达式==
* ==后置：先计算表达式，然后对变量本身进行++运算==

```c
//3、++ --运算符
void test05()
{
	//作为独立语句，前置和后置没有区别
	//后置递增
	int num = 10;
	num++;
	printf("num=%d\n", num);

	//后置递增
	int num2 = 10;
	++num2;
	printf("num2=%d\n", num2);

	//作为复合运算，前置和后置运算有区别
	//前置
	int a = 10;
	int b = ++a * 10;//先对变量本身进行++运算，再计算表达式
	printf("a=%d\n", a);//11
	printf("b=%d\n", b);//110

	//后置
	int a2 = 10;
	int b2 = a2++ * 10;//先计算表达式，然后对变量本身进行++运算
	printf("a2=%d\n", a2);//11
	printf("b2=%d\n", b2);//100

	//建议在表达式运算的时候，不要同时有前置和后置++运算，结果产生歧义
	int a3 = 10;
	int b3 = 10;
	b3 = ++a3 * a3++ - ++a3;//先算前置++得a3=12  所以12*12-12=132   ，算完这个表达式之后再算后置++，此时a3=13
	printf("a3=%d\n", a3);//13
	printf("b3=%d\n", b3);//132
}
```

## 3.3 赋值运算符

| **运算符** | **术语** | **示例**   | **结果**  |
| ---------- | -------- | ---------- | --------- |
| =          | 赋值     | a=2; b=3;  | a=2; b=3; |
| +=         | 加等于   | a=0; a+=2; | a=2;      |
| -=         | 减等于   | a=5; a-=3; | a=2;      |
| *=         | 乘等于   | a=2; a*=2; | a=4;      |
| /=         | 除等于   | a=4; a/=2; | a=2;      |
| %=         | 模等于   | a=3; a%2;  | a=1;      |

* ==**左值**==：能够在等号左边的值称为左值
* ==**右值**==：只能在等号右边的值称为右值

```c
void test01()
{
	int a = 10;
	a = 20;
    
	int b = 0;
	b = a;//b是左值，a也是左值
}

void test02()
{
	int a = 10;
	a += 2;// a = a + 2;
	printf("a=%d\n", a);

	a = 10;
	a -= 2;// a = a - 2;
	printf("a=%d\n", a);

	a = 10;
	a *= 2;// a = a * 2;
	printf("a=%d\n", a);

	a = 10;
	a /= 2;// a = a / 2;
	printf("a=%d\n", a);

	a = 10;
	a %= 2;// a = a % 2;
	printf("a=%d\n", a);
}
```

* ==复合运算时，等号右边的表达式要看成一个整体==

```c
void test03()
{
	int num = 10;
	num *= 3 + 5;//复合运算时，等号右边的表达式要看成一个整体
	//相当于num*=(3+5);
	printf("num=%d\n", num);//80
}
```

## 3.4 比较运算符

| **运算符** | **术语** | **示例** | **结果** |
| ---------- | -------- | -------- | -------- |
| ==         | 相等于   | 4 == 3   | 0        |
| !=         | 不等于   | 4 != 3   | 1        |
| <          | 小于     | 4 < 3    | 0        |
| >          | 大于     | 4 > 3    | 1        |
| <=         | 小于等于 | 4 <= 3   | 0        |
| >=         | 大于等于 | 4 >= 1   | 1        |

**==0代表假，非0代表真==**

```c
void test01()
{
	int a = 10;
	int b = 20;
	printf("a==b %d\n", a == b);// 0两个==，一个等号代表赋值
	printf("a!=b %d\n", a != b);//1
	printf("a>b %d\n", a > b);//0
	printf("a>=b %d\n", a >= b);//1
	printf("a<b %d\n", a < b);//0
	printf("a<=b %d\n", a <= b);//1
}
```

## 3.5 逻辑运算符

| **运算符** | **术语** | **示例** | **结果**                                                 |
| ---------- | -------- | -------- | -------------------------------------------------------- |
| !          | 非       | !a       | 如果a为假，则!a为真；如果a为真，则!a为假。               |
| &&         | 与       | a && b   | 如果a和b都为真，则结果为真，否则为假。                   |
| \|\|       | 或       | a \|\| b | 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 |

1、**逻辑非 ！**    ==**非真为假，非假为真**==

```c
void test01()
{
	int a = 10;
	printf("!a= %d\n", !a);//0
	printf("!!a= %d\n", !!a);//1

	printf("!100= %d\n", !100);//0
	printf("!0= %d\n", !0);//1
	printf("!-100= %d\n", !-100);//0
}
```

2、**逻辑与 &&**       ==**同真为真，其余为假**==

表达式1 && 表达式2

* ==短路特性==：只有表达式1为真，才会执行表达式2

```c
void test02()
{
	int level = 10;
	int vip = 5;
	printf("level&&vip= %d\n", level > 5 && vip > 3);

	level = 3;
	vip = 20;
	printf("level&&vip= %d\n", level > 5 && vip > 3);

	level = 30;
	vip = 0;
	printf("level&&vip= %d\n", level > 5 && vip > 3);

	level = 3;
	vip = 0;
	printf("level&&vip= %d\n", level > 5 && vip > 3);

	//同真为真，其余为假
	//短路特性  只有表达式1为真，才会执行表达式2
	//表达式1 && 表达式2
	4 < 3 && printf("hello1\n");//只有表达式1为真，才会执行表达式2
	4 > 3 && printf("hello2\n");//只有表达式1为真，才会执行表达式2
}
```

3、**逻辑或 ||**          ==**同假为假，其余为真**==

表达式1 || 表达式2

* ==短路特性==：只有表达式1为假，才会执行表达式2

```c
void test03()
{
	int level = 10;
	int vip = 5;
	printf("level||vip= %d\n", level > 5 || vip > 3);

	level = 3;
	vip = 20;
	printf("level||vip= %d\n", level > 5 || vip > 3);

	level = 30;
	vip = 0;
	printf("level||vip= %d\n", level > 5 || vip > 3);

	level = 3;
	vip = 0;
	printf("level||vip= %d\n", level > 5 || vip > 3);

	//同假为假，其余为真
	//短路特性  只有表达式1为假，才会执行表达式2
	//表达式1 || 表达式2
	4 < 3 || printf("hello1\n");//只有表达式1为假，才会执行表达式2
	4 > 3 || printf("hello2\n");//只有表达式1为假，才会执行表达式2
}
```

## 3.6 三木运算符

语法：**表达式1？表达式2：表达式3**

==解释：如果表达式1为真，则执行表达式2，否则执行表达式3==

```c
void test01()
{
	int a = 10;
	int b = 20;
	int c = 0;

	c = a > b ? a : b;//c=20

	printf("a=%d\n", a);
	printf("b=%d\n", b);
	printf("c=%d\n", c);//20

	//和if语句的比较：
	//三目运算符优点短小、整洁
	//缺点是如果用嵌套语句，结构没有if语句清晰
}
```

## 3.7 运算符优先级

==**运算符优先级顺序：赋值运算符 < 逻辑运算符 < 比较运算符 < 算术运算符**==

| **优先级** | **运算符** | **名称或含义**   | **使用形式**             | **结合方向** | **说明**   |
| ---------- | ---------- | ---------------- | ------------------------ | ------------ | ---------- |
| **1**      | **[]**     | 数组下标         | 数组名[常量表达式]       | 左到右       | --         |
|            | **()**     | 圆括号           | (表达式）/函数名(形参表) |              | --         |
|            | **.**      | 成员选择（对象） | 对象.成员名              |              | --         |
|            | **->**     | 成员选择（指针） | 对象指针->成员名         |              | --         |
|            |            |                  |                          |              |            |
| **2**      | **-**      | 负号运算符       | -表达式                  | 右到左       | 单目运算符 |
|            | **~**      | 按位取反运算符   | ~表达式                  |              |            |
|            | **++**     | 自增运算符       | ++变量名/变量名++        |              |            |
|            | **--**     | 自减运算符       | --变量名/变量名--        |              |            |
|            | *****      | 取值运算符       | *指针变量                |              |            |
|            | **&**      | 取地址运算符     | &变量名                  |              |            |
|            | **!**      | 逻辑非运算符     | !表达式                  |              |            |
|            | **(类型)** | 强制类型转换     | (数据类型)表达式         |              | --         |
|            | **sizeof** | 长度运算符       | sizeof(表达式)           |              | --         |
|            |            |                  |                          |              |            |
| **3**      | **/**      | 除               | 表达式/表达式            | 左到右       | 双目运算符 |
|            | *****      | 乘               | 表达式*表达式            |              |            |
|            | **%**      | 余数（取模）     | 整型表达式%整型表达式    |              |            |
| **4**      | **+**      | 加               | 表达式+表达式            | 左到右       | 双目运算符 |
|            | **-**      | 减               | 表达式-表达式            |              |            |
| **5**      | **<<**     | 左移             | 变量<<表达式             | 左到右       | 双目运算符 |
|            | **>>**     | 右移             | 变量>>表达式             |              |            |
|            |            |                  |                          |              |            |
| **6**      | **>**      | 大于             | 表达式>表达式            | 左到右       | 双目运算符 |
|            | **>=**     | 大于等于         | 表达式>=表达式           |              |            |
|            | **<**      | 小于             | 表达式<表达式            |              |            |
|            | **<=**     | 小于等于         | 表达式<=表达式           |              |            |
| **7**      | **==**     | 等于             | 表达式==表达式           | 左到右       | 双目运算符 |
|            | **！=**    | 不等于           | 表达式!= 表达式          |              |            |
|            |            |                  |                          |              |            |
| **8**      | **&**      | 按位与           | 表达式&表达式            | 左到右       | 双目运算符 |
| **9**      | **^**      | 按位异或         | 表达式^表达式            | 左到右       | 双目运算符 |
| **10**     | **\|**     | 按位或           | 表达式\|表达式           | 左到右       | 双目运算符 |
| **11**     | **&&**     | 逻辑与           | 表达式&&表达式           | 左到右       | 双目运算符 |
| **12**     | **\|\|**   | 逻辑或           | 表达式\|\|表达式         | 左到右       | 双目运算符 |
|            |            |                  |                          |              |            |
| **13**     | **?:**     | 条件运算符       | 表达式1?表达式2: 表达式3 | 右到左       | 三目运算符 |
|            |            |                  |                          |              |            |
| **14**     | **=**      | 赋值运算符       | 变量=表达式              | 右到左       | --         |
|            | **/=**     | 除后赋值         | 变量/=表达式             |              | --         |
|            | ***=**     | 乘后赋值         | 变量*=表达式             |              | --         |
|            | **%=**     | 取模后赋值       | 变量%=表达式             |              | --         |
|            | **+=**     | 加后赋值         | 变量+=表达式             |              | --         |
|            | **-=**     | 减后赋值         | 变量-=表达式             |              | --         |
|            | **<<=**    | 左移后赋值       | 变量<<=表达式            |              | --         |
|            | **>>=**    | 右移后赋值       | 变量>>=表达式            |              | --         |
|            | **&=**     | 按位与后赋值     | 变量&=表达式             |              | --         |
|            | **^=**     | 按位异或后赋值   | 变量^=表达式             |              | --         |
|            | **\|=**    | 按位或后赋值     | 变量\|=表达式            |              | --         |
|            |            |                  |                          |              |            |
| **15**     | **，**     | 逗号运算符       | 表达式,表达式,…          | 左到右       | --         |

```c
void test01()
{
	//自增运算符 优先级高于 乘法运算
	int a = 10;
	printf("%d\n", ++a * 10);//110
}

void test02()
{
	//比较运算符 高于 赋值运算符
	int a = 10;
	printf("%d\n", a = 23 > 24);//0
}

void test03()
{
	//逻辑与 优先级高于 逻辑或
	printf("%d\n", 1 || 1 && 0);//1，先运算后面，再运算前面
}

void test04()
{
	//赋值运算符  同样优先级看结合性，赋值运算符结合性从右向左
	int a = 10;
	a += a -= a *= a /= 5;
	printf("a%d\n", a);
}

void test05()
{
	//,优先级最低
	int num = 0;
	num = 1, 2, 3, 4;//=优先级大于,
	printf("num=%d\n", num);//1

	//有个()，先计算()里面，再计算赋值=，逗号优先级从左往右
	num = (1, 2, 3, 4);//4
	printf("num=%d\n", num);
}
```

## 3.8 类型转换

==类型转换的原则==：占用内存字节数少(值域小)的类型，向占用内存字节数多(值域大)的类型转换，以保证精度不降低。

![img](file:///C:\Users\wenca\AppData\Local\Temp\ksohtml\wps44F1.tmp.jpg)

### 3.8.1 自动类型转换（隐式类型转换）

* 小数据类型可以自动转大数据类型，大数据类型转小数据类型可能会溢出
* ==char和short是比较小的类型，容易出现溢出现象，所以运算时编译器会将他们转为int再进行运算，防止溢出==

```c
void test01()
{
	//int 和 double运算，会自动将int转为double
	printf("%d\n", sizeof(5 / 2.0));
}

//注意：大数据类型转小数据类型可能会溢出
void test02()
{
	int num = 353;
	//原码 1 0110 0001
	
	//原码溢出了，会把0110 0001给ch
	// 97 ~ 'a'
	char ch = num;//只有一个字节（8位）
	printf("%c\n", ch);
}

void test03()
{
	//char和short是比较小的类型，容易出现溢出现象，所以运算时编译器会将他们转为int再进行运算，防止溢出
	char a = 10;
	short b = 10;
	printf("%d\n", sizeof(a + a));
	printf("%d\n", sizeof(b + b));
	printf("%d\n", sizeof(a + b));
}
```

### 3.8.2 强制类型转换

==**(类型说明符) (表达式)**==

```c
void test05()
{
	float price = 1.6;//黄瓜 单价1.6
	int num = 2;

	int sum = num * (int)price;//2  强制类型转换
	printf("%d\n", sum);

	int sum2 = (int)(num * price);//3  强制类型转换
	printf("%d\n", sum2);
}
```

# 4 程序流程结构

## 4.1 顺序结构



## 4.2 选择结构

### 4.2.1 单行if语句

```c
void test01()
{
	int score = 0;
	printf("请输入一个分数：\n");
	scanf("%d", &score);
	printf("您输入的分数是：%d", score);
	if (score > 600)
	{
		printf("恭喜您考上了一本大学\n");
	}
}
```

### 4.2.2 多行if语句

```c
void test02()
{
	int score = 0;
	printf("请输入一个分数：\n");
	scanf("%d", &score);
	printf("您输入的分数是：%d", score);
	if (score > 600)
	{
		printf("恭喜您考上了一本大学\n");
	}
	else//未满足条件，执行这个分支
	{
		printf("未考上一本大学\n");
	}
}
```

### 4.2.3 多条件if语句

```c
void test03()
{
	int score = 0;
	printf("请输入一个分数：\n");
	scanf("%d", &score);
	printf("您输入的分数是：%d", score);
	if (score > 600)
	{
		printf("恭喜您考上了一本大学\n");
	}
	else if(score > 500)//未满足条件，执行这个分支
	{
		printf("恭喜考上二本大学\n");
	}
	else if(score > 400)
	{
		printf("恭喜考上三本大学\n");
	}
	else
	{
		printf("没有考入本科\n");
	}
}
```

### 4.2.4 嵌套if语句

```c
void test04()
{
	int score = 0;
	printf("请输入一个分数：\n");
	scanf("%d", &score);
	printf("您输入的分数是：%d", score);
	if (score > 600)
	{
		printf("恭喜您考上了一本大学\n");
		if (score > 700)
		{
			printf("考入了北京大学\n");
		}
		else if(score > 650)
		{
			printf("考入了清华大学\n");
		}
		else
		{
			printf("考入了其他大学\n");
		}
	}
	else if (score > 500)//未满足条件，执行这个分支
	{
		printf("恭喜考上二本大学\n");
	}
	else if (score > 400)
	{
		printf("恭喜考上三本大学\n");
	}
	else
	{
		printf("没有考入本科\n");
	}
}
```

### 4.2.5 if语句的注意事项

* 不要在if语句的后面加分号，如果加如分号，后面的代码肯定会执行
* if语句如果不加{}，只能识别最近一行代码
* 做对比操作时，不要写成=，而是用==

```c
void test05()
{
	//1、不要在if语句的后面加分号
	int a = 10;
	int b = 20;
	if (a > b);//如果加如分号，后面的代码肯定会执行
	{
		printf("a>b\n");
	}

	//2、if语句如果不加{}，只能识别最近一行代码
	if (a > b)
		printf("a>b\n");//不执行
	printf("a>b\n");//执行

	//3、做对比操作时，不要写成=，而是用==
	int num = 5;
	if (num = 10)
	{
		printf("num==10\n");
	}
	else
	{
		printf("num!=10\n");
	}
}
```

### 4.2.6 if语句案例：三只小猪称体重

```c
void test06()
{
	//1、创建三只小猪的重量的变量
	int num1 = 0;
	int num2 = 0;
	int num3 = 0;

	//2、让用户输入三只小猪的重量
	printf("请输入三只小猪的重量：\n");
	printf("小猪1的体重为：");
	scanf("%d", &num1);
	printf("小猪2的体重为：");
	scanf("%d", &num2);
	printf("小猪3的体重为：");
	scanf("%d", &num3);

	//3、比较三只小猪的重量
	if (num1 > num2)
	{
		if (num1 > num3)
		{
			printf("小猪1最重\n");
		}
		else
		{
			printf("小猪3最重\n");
		}
	}
	else
	{
		if (num2 > num3)
		{
			printf("小猪2最重\n");
		}
		else
		{
			printf("小猪3最重\n");
		}
	}

}
```

### 4.2.7 三木运算符

```c
//三目运算符
//语法：表达式1？表达式2：表达式3
//解释：如果表达式1为真，则执行表达式2，否则执行表达式3
void test01()
{
	int a = 10;
	int b = 20;
	int c = 0;

	c = a > b ? a : b;//c=20

	printf("a=%d\n", a);
	printf("b=%d\n", b);
	printf("c=%d\n", c);//20

	//和if语句的比较：
	//三目运算符优点短小、整洁
	//缺点是如果用嵌套语句，结构没有if语句清晰
}
```

### 4.2.8 switch语句

switch语句和if语句比较：

对于多条件判断的时候，结构比较清晰，==执行效率高==（可以用逐条语句去查看调试）

缺点：数据类型具有局限性，判断区间比较麻烦

**switch后面的条件只能是 ==整型== 或者是 ==char型==**

```c
void test01()
{
	int score = 0;
	printf("请个电影打分：\n");
	scanf("%d", &score);
	switch (score)//条件只能是 整型 或者是 char型
	{
	case 10:
	case 9:
		printf("经典\n");
		break;//结束当前分支
	case 8:
	case 7:
		printf("非常好\n");
		break;//结束当前分支
	case 6:
	case 5:
		printf("一般\n");
		break;//结束当前分支
	default:
		printf("烂片\n");
		break;//结束当前分支
	}
}
```

## 4.3 循环结构

### 4.3.1 while循环

执行循环的时候，程序必须右跳出循环的出口，否则无限循环

```c
void test01()
{
	int num = 0;
	while (num < 10)
	{
		num++;
		printf("num=%d\n", num);
	}
	printf("hello world\n");
	//执行循环的时候，程序必须右跳出循环的出口，否则无限循环
}
```

### 4.3.2 while循环案例：猜数字

系统产生一个1~100之间的随机数，我们进行猜测，如果猜不对，系统提示，直到猜正确为止

```c
void test02()
{
	//添加随机数种子，让该数真正随机
	//time(NULL)根据1970年1月1日0:0:0至今的秒数
	//(unsigned int)表示强制类型转换
	//在使用的时候需要包含一个头文件   #include<time.h>
	//如果还有其他地方也要随机数，只需要设置一次足以
	srand((unsigned int)time(NULL));

	//1、让系统产生随机数
	int num = rand() % 100 + 1;//1~100之间的随机数

	//2、玩家猜测
	while (1)
	{
		int val = 0;//用户猜测的数据
		printf("请输入您的猜测数据：\n");
		scanf("%d", &val);
		if (val > num)
		{
			printf("猜测过大\n");
		}
		else if(val < num)
		{
			printf("猜测过小\n");
		}
		else
		{
			printf("恭喜您猜对啦\n");
			break;//退出当前循环
		}
	}
}
```

### 4.3.3 do while循环

do while和while的区别在于do while会先执行一次循环语句，然后再判断循环条件

```c
void test01()
{
	int num = 0;
	do
	{
		printf("%d\n", num);
		num++;
	} while (num < 10);
	//do while和while的区别在于do while会先执行一次循环语句，然后再判断循环条件
}
```

### 4.3.4 do while循环案例：水仙花数

求所有三位数的水仙花数：个位^3 + 十位^3 + 百位^3 = 该数字

```c
void test02()
{
	//1、打印出所有3位数字
	int num = 100;
	do
	{
		int a = 0;//个位
		int b = 0;//十位
		int c = 0;//百位
		a = num % 10;
		b = num / 10 % 10;
		c = num / 100;
        
        //2、再判断是水仙花数才去打印
		if (a * a * a + b * b * b + c * c * c == num)
		{
			printf("%d\n", num);
		}
		num++;
	} while (num<1000);
}
```

### 4.3.5 for循环

for ( 起始表达式 ; 条件表达式 ; 末尾循环体 ) { 循环语句 }

==for里面的3个条件是可以省略的==

```c
void test01()
{
	for (int i = 0; i < 10; i++)
	{
		printf("i=%d\n", i);
	}
    
	//和上面一样的效果
	//for里面的3个条件是可以省略的
	int i = 0;
	for (;;)
	{
		if (i == 10)
		{
			break;
		}
		printf("i=%d\n", i);
		i++;
	}
}
```

### 4.3.6 for循环案例1：敲桌子

从1开始一直到100打印，如果数字的个位或者十位有7，或者数字是7的倍数，打印敲桌子

```c
void test02()
{
	for (int i = 1; i <= 100; i++)
	{
		if (i % 10 == 7 || i / 10 == 7 || i % 7 == 0)
		{
			printf("敲桌子 ");
		}
		else
		{
			printf("%d ", i);
		}
	}
}
```

### 4.3.7 for循环案例2：找质数

质数：只能被1和自身整除的数

```c
int Prime_number(int i)
{
	for (int j = 2; j < i; j++)  //让他一直循环，让他与每一个数取余
	{
		if (i % j == 0)  //出现整除的立马结束循环
		{
			return 0;
		}
	}
	return 1;  //如果没有出现整除的，一直执行循环，直到达到退出循环条件
}

void test01()
{
	for (int i = 101; i < 200; i++)
	{
		if (Prime_number(i) == 1)
		{
			printf("%d\n", i);
		}
	}
}
```



### 4.3.8 嵌套循环

```c
void test01()
{
	for (int i = 0; i < 10; i++)//外层循环i控制行数
	{
		for (int j = 0; j < 10; j++)//内层循环j控制列数
		{
			printf("* ");
		}
		printf("\n");
	}
}
```

### 4.3.9 嵌套循环案例：九九乘法表

```c
void test02()
{
	for (int i = 1; i < 10; i++)
	{
		for (int j = 1; j < i+1; j++)
		{
			printf("%d*%d=%d\t", j, i, i * j);
		}
		printf("\n");
	}
}
```

### 4.3.10 跳转语句（break、continue、goto）

#### （1）break跳转语句

* 用在switch语句中，结束分支
* 用在循环中，退出当前循环
* 用在循环嵌套中，退出内层循环
* ==**break是退出循环，return是退出函数**==

```c
void test01()
{
	for (int i = 0; i < 10; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			if (i == 5)
			{
				break;//循环嵌套时，退出内层循环
			}
			printf("* ");
		}
		printf("\n");
	}
}
```

#### （2）continue跳转语句

==终止本次循环，并继续执行下一次循环==

```c
void test02()
{
	for (int i = 0; i < 100; i++)
	{
		if (i % 2 == 0)//输出奇数
		{
			continue;//不会退出循环，只是退出本次循环，和break不同
			//break;
		}
		printf("%d ", i);
	}
}
```

#### （3）goto跳转语句

==无条件跳转==，尽量少用，最好不用，会严重影响程序的逻辑结构

```c
void test03()
{
	printf("hello1\n");
	printf("hello2\n");

	goto FLAG;

	printf("hello3\n");
	printf("hello4\n");

	FLAG:
	printf("hello5\n");
	printf("hello6\n");
}
```

# 5 数组和字符串

==数组就是在内存中**连续的相同类型的变量空间**==

## 5.1 一维数组

### 5.1.1 一维数组的定义和初始化（三种定义方式）

（1）定义方式一：数据类型 数组名[元素个数]

```c
	int scores[10];//数据类型 数组名[元素个数]

	//给数组中的元素赋值（初始化）
	scores[0] = 100;
	scores[1] = 200;
	scores[2] = 300;
	scores[3] = 400;

	//访问数组中的元素，里利用下标
	printf("%d\n", scores[0]);
	printf("%d\n", scores[1]);
	printf("%d\n", scores[2]);
	printf("%d\n", scores[3]);
```

（2）定义方式二：数据类型 数组名[元素个数]={值1，值2，值3}

* 值的个数小于元素个数时，未初始化内容用0填补

```c
	//int scores[10] = { 10,20,30,40,50,60,70,80,90,100 };
	int scores[10] = { 10,20,30,40,50 };//部分初始化，未初始化内容用0填补
	//int scores[10];//未知

	//对第一、五、九个元素进行赋值，其他元素用0进行填补
	//int scores[10] = { [0] = 10,[4] = 50,[8] = 90 };//部分初始化，未初始化内容用0填补
	for (int i = 0; i < 10; i++)
	{
		printf("%d\n", scores[i]);
	}
```

（3）定义方式三：数据类型 数组名[]={值1 ，值2，值3}，==用这种方式定义数组时，必须要同时赋值才不会报错==

```c
	int scores[] = { 10,20,30,40,50,60,70,80,90,100 };
	//int scores[];//会报错
	for (int i = 0; i < 10; i++)
	{
		printf("%d\n", scores[i]);
	}
```

==**注意：数组在指定元素个数时，必须是常量，不可以是变量**==

```c
	int a = 10;
	//int arr[a];//报错。因为元素个数必须是常量，不可以是变量
```

### 5.1.2 一维数组名称的用途

（1）==利用 sizeof ( 数组名 ) 可以统计整个数组占用内存空间大小==

（2）利用 sizeof ( 数组中的任意一个元素 ) 统计每个元素占用的内存空间

（3）利用 sizeof ( 数组名 ) /sizeof ( 数组的数据类型 ) 统计数组的元素个数

```c
	//利用sizeof(数组名)可以统计整个数组占用内存空间大小
	printf("%d\n", sizeof(arr));

	//利用sizeof()统计每个元素占用的内存空间
	printf("sizeof arr[0]=%d\n", sizeof(arr[0]));

	//利用sizeof()统计数组的元素个数
	printf("元素个数：%d\n", sizeof(arr) / sizeof(int));
```

（4）==利用数组名，可以获取数组的首地址==

```c
	printf("首地址：%d\n", arr);
	printf("数组中第一个元素的地址：%d\n", &arr[0]);
	printf("数组中第二个元素的地址：%d\n", &arr[1]);//验证地址是连续空间
```

（5）数组名是一个常量，不可以修改的

```c
	arr = 100;//报错。数组名是常量，不可以修改
```

###5.1.3 一维数组案例1：选择排序

==**选择排序**==：如果遍历数组的时候，值大于我们开始认定的值，更新最大值下标

```c
void test03()
{
	int arr[5];
	//手动给猪赋值
	printf("请输入五只小猪的体重：\n");
	int len = sizeof(arr) / sizeof(int);
	for (int i = 0; i < len; i++)
	{
		scanf("%d", &arr[i]);
	}

	int max = 0;//认定最大值的下标为0

	//选择排序（比一轮）
	for (int i = 0; i < 5; i++)
	{
		if (arr[max] < arr[i])
		{
			max = i;//如果遍历数组的时候，值大于我们开始认定的值，更新最大值下标
		}
	}
	printf("最重的小猪%d体重为：%d\n", max + 1, arr[max]);
}
```

### 5.1.4 一维数组案例2：冒泡排序

冒泡排序：比较相邻的元素，如果前一个比后一个大，则交换顺序（升序），反之，降序

```c
	//冒泡排序（升序）
	for (int i = 0; i < len - 1; i++)//对比的轮数
	{
		for (int j = i + 1; j < len; j++)//每轮对比的次数
		{
			if (arr[i] > arr[j])//交换
			{
				int temp = arr[i];
				arr[i] = arr[j];
				arr[j] = temp;
			}
		}
	}
	printf("\n升序后的数组为：\n");
	for (int i = 0; i < len; i++)
	{
		printf("arr[%d]=%d ", i, arr[i]);

	}
```

```c
	//冒泡排序（降序）
	for (int i = 0; i < len - 1; i++)//对比的轮数
	{
		for (int j = i + 1; j < len; j++)//每轮对比的次数
		{
			if (arr[i] < arr[j])//交换
			{
				int temp = arr[i];
				arr[i] = arr[j];
				arr[j] = temp;
			}
		}
	}
	printf("\n降序后的数组为：\n");
	for (int i = 0; i < len; i++)
	{
		printf("arr[%d]=%d ", i, arr[i]);

	}
	printf("\n");
```

### 5.1.5一维数组案例3：元素逆置

需求：1 3 5 4 2  逆置后  2 4 5 3 1 ，就是元素的交换

```c
void test01()
{
	int arr[5];
	int len = sizeof(arr) / sizeof(int);//数组长度
	printf("请输入一个数组：\n");
	for (int i = 0; i < len; i++)
	{
		scanf("%d", &arr[i]);
	}
	printf("逆序前的数组为：\n");
	for (int i = 0; i < len; i++)
	{
		printf("arr[%d]=%d\n", i, arr[i]);
	}

	for (int i = 0; i < len / 2; i++)    //实现元素的逆置
	{
		int temp = arr[i];
		arr[i] = arr[len - i - 1];
		arr[len - i - 1] = temp;
	}
	printf("逆序后的数组为：\n");
	for (int i=0; i < len; i++)
	{
		printf("arr[%d]=%d\n", i, arr[i]);
	}
}
```

## 5.2 二维数组

在内存中并不存在二维数组，==**二维数组实际的硬件存储器是连续编址的，也就是说内存中只有一维数组**==，即放完一行之后顺次放入第二

行，和一维数组存放方式是一样的。

### 5.2.1 二维数组的定义和初始化（四种定义方式）

（1）定义方式一：数据类型 数组名[行数] [列数]

```c
	int arr[2][3];//定义

	arr[0][0] = 1;//赋值
	arr[0][1] = 2;
	arr[0][2] = 3;
	arr[1][0] = 4;
	arr[1][1] = 5;
	arr[1][2] = 6;

	for (int i = 0; i < 2; i++)//输出
	{
		for (int j = 0; j < 3; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
```

（2）定义方式二：数据类型 数组名[行数] [列数] = { {1,2,3,...} ，{4,5,6...}，{7,8,9...}，.....}

==最后一行末尾的逗号可写可不写==

```c
	int arr2[2][3] =
	{
		{1,2,3},
		{4,5,6}//最后一行末尾的逗号可写可不写
	};
```

（3）定义方式三：数据类型 数组名[行数] [列数] = { 1, 2, 3, 4, 5, 6,... }

```c
	int arr3[2][3] = { 1,2,3,4,5,6 };
```

（4）定义方式四：数据类型 数组名[] [列数] = { 1, 2, 3, 4, 5, 6,... }

可以省略行数，不可以省略列数，未初始化部分用0填补

```c
	int arr4[][3] = { 1,2,3,4,5,6,7 };
```

### 5.2.2 二维数组名称的用途

（1）sizeof ( arr ) 统计整个数组的大小

```c
	printf("sizeof arr=%d\n", sizeof(arr));
```

（2）sizeof ( arr[0] ) 统计一行数组的大小

```c
	printf("sizeof arr=%d\n", sizeof(arr[0]));
```

（3）sizeof ( arr[0] [0] ) 统计一个元素的内存大小

```c
	printf("sizeof arr=%d\n", sizeof(arr[0][0]));
```

（4）获取行数和列数

```c
	printf("二维数组的行数：%d\n", sizeof(arr) / sizeof(arr[0]));
	printf("二位数组的列数：%d\n", sizeof(arr[0]) / sizeof(arr[0][0]));
```

（5）二维数组的首地址：二维数组的数组名就是数组的首地址

```c
	printf("二维数组的首地址%d\n", arr);
	printf("二维数组的第一行首地址%d\n", arr[0]);
	printf("二维数组的第二行首地址%d\n", arr[1]);
	printf("二维数组的第一个元素首地址%d\n", &arr[0][0]);
	printf("二维数组的第二个元素首地址%d\n", &arr[0][1]);
```

### 5.2.3 二维数组案例：打印考试成绩

```c
void test03()
{
	int scores[3][3] =
	{
		{100,100,100},
		{90,80,70},
		{60,100,85}
	};

	//char str[] = "hello world";//字符数组
    
	//这是一个三行十列的数组，张三代表第一行，李四代表第二行，王五代表第三行
	char names[3][10] = { "张三","李四","王五" };

	int row = sizeof(scores) / sizeof(scores[0]);//行数
	int col = sizeof(scores[0]) / sizeof(scores[0][0]);//列数
	//打印出每个人的总成绩
	for (int i = 0; i < row; i++)
	{
		int sum = 0;
		for (int j = 0; j < col; j++)
		{
			sum += scores[i][j];
		}
		printf("%s同学的总分为：%d\n", names[i], sum);
		printf("%s同学的平均分为：%d\n", names[i], sum / col);
	}
}
```

## 5.3 字符数组与字符串

==**数字0 ( 和字符 ‘ \0 ’ 等价 ) 结尾的 char 数组就是一个字符串，但如果 char 数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的 char 的数组。**==

### 5.3.1 字符数组的定义和初始化（三种定义方式）

（1）**定义方式一**：数据类型 数组名[元素个数]

```c
	//字符数组的定义，定义一维数组，每个元素char，一共5个元素
	char arr[5];
	printf("sizeof=%d\n", sizeof(arr));
```

（2）**定义方式二**：数据类型 数组名[元素个数] = {'h','e','l','l','o','\0'};

初始化字符数组时，要注意：

​	==利用%s进行输出：直接输出数组名即可，但是字符数组一定要有结尾标识符' \0 '==

```c
	printf("%s\n", arr);
```

​	==利用%c进行输出：输出的是数组元素==

```c
	for (int i = 0; i < 5; i++)
	{
		printf("%c", arr[i]);
	}
	printf("\n");
```

* ==未在结尾加' \0 '时：利用%s输出会出现乱码，只能利用%c循环遍历，挨个字符输出==
* ==在结尾加了' \0 '时：==

​		==1）利用%s输出时，可以直接输出整个字符串==

​		==2）利用%c输出时，遇到' \0 '结束输出==

```c
	//char arr[5] = { 'h','e','l','l','o' };//错误。利用%s输出时会乱码，因为无\0结束符
	char arr[6] = { 'h','e','l','l','o','\0'};//正确

	//字符数组的两种输出方式：	
	//1、输出方式一：利用%c循环遍历，挨个字符输出
	for (int i = 0; i < 5; i++)
	{
		printf("%c", arr[i]);
	}
	printf("\n");

	//2、输出方式二：利用%s直接输出整个字符串
	printf("%s\n", arr);//这个好一点，但是要注意后面多了一个\n，不加\0会出现乱码
```

（3）定义方式三：数据类型 数组名 [ 元素个数 ] = "hello"；

​	==建议用这种方式去初始化，其末尾自动包含了结尾标识符 ' \0 '==

```c
	char arr[6] = "hello";//建议用这种方式去初始化，其后面自动包含了一个\0
	printf("%s\n", arr);
```

### 5.3.2 字符串中字符长度的统计：sizeof 和 strlen 函数的区别

* **==strlen 统计字符的长度，包括空格，但是不统计 ’ \0 ‘==**
* **==sizeof 除了统计字符串长度，还会统计\0，统计整个数组占用的内存大小==**

```c
	char str1[32] = "hello world";
	//strlen统计字符的长度
	printf("%d\n", strlen(str1));//11个字符 包括空格，但是不统计\0
	printf("%d\n", sizeof(str1));//32 统计整个数组占用的内存大小

	char str2[] = "hello world";
	//strlen统计字符的长度
	printf("%d\n", strlen(str2));//11个字符 包括空格，但是不统计\0
	printf("%d\n", sizeof(str2));//12 除了统计字符串长度，还会统计\0，统计整个数组占用的内存大小

	char str3[] = "hello\0world";
	//strlen统计字符的长度
	printf("%d\n", strlen(str3));//5  遇到\0就统计结束
	printf("%d\n", sizeof(str3));//12  10+2个\0
```

​	**注意转义字符的应用**：

```c
	//提高
	//  //2个  \\1个  1 1个  \123 1个 abc 3个  \xac 1个  hehe 4个
	char str4[] = "//\\1\123abc\xachehe";
	//strlen统计字符的长度
	printf("%d\n", strlen(str4));//13 不含\0
	printf("%d\n", sizeof(str4));//14 多加了一个\0
```

## 5.4 字符数组的输入

​	**输入前，得先准备一个空数组用于接受屏幕对其的输入。**

### （1）scanf 函数输入

​	==scanf 输入字符串时，不能输入空格，因为他遇到空格符会输入结束。==不能把用户的回车当作字符串的一部分

```c
void test05()
{
	//两种方式初始化都为0
	//char buf[16] = "";
	char buf[16] = { 0 };//准备一个数组用于接受屏幕的输入

	scanf("%s", buf);//scanf输入字符串时，遇到空格会结束
	printf("%s\n", buf);
}
```

### （2）gets 函数输入

​	==可以输入空格，不推荐用，原因是没有检测越界的情况，一旦越界，程序奔溃。==不能把用户的回车当作字符串的一部分

```c
	char buf[16] = { 0 };
	gets(buf);
	printf("%s\n", buf);
```

### （3）fgets 函数输入

​	==**fgets 函数在读取一个用户通过键盘输入的字符串的时候，同时把用户输入的回车也做为字符串的一部分。**==

​	==可以输入空格，推荐使用，比较安全，程序超出后不会奔溃。==

```c
	fgets(buf, sizeof(buf), stdin);//stdin标准输入设备
	printf("%s\n", buf);
```

## 5.5 字符数组的输出

### （1）printf 函数输出

​	字符数组输出完成之后，不会自动换行

```c
	char buf[16] = "hello world";	
	printf("%s\n", buf);
```

### （2）puts 函数输出

​	字符数组输出完成之后，会自动换行

```c
	char buf[16] = "hello world";
	puts(buf);//自带换行输出
```

### （3）fputs 函数输出

​	字符数组输出完成之后，不会自动换行

```c
	char buf[16] = "hello world";	
	fputs(buf, stdout);//stdout标准输出设备，不带换行符
```

```c
void test08()
{
	char buf[16] = { 0 };
	fgets(buf, sizeof(buf), stdin);//输入时，同时会把回车当作输入的一部分
	//printf("%s\n", buf);//输出时，不会自动换行，但是之前已经输出了一个换行，因此有一个换行
	//fputs(buf, stdout);//输出时，不会自动换行，但是之前已经输出了一个换行，因此有一个换行
	puts(buf);//输出完成之后（注意此时已经输入了一个换行），会自动换行，因此相当于有两个换行
}
```

## 5.6 字符串处理函数

### （1）gets 函数：标准输入

```c
#include <stdio.h>
char *gets(char *s);
功能：从标准输入读入字符，并保存到s指定的内存空间，直到出现换行符或读到文件结尾为止。
参数：
	s：字符串首地址
返回值：
	成功：读入的字符串
	失败：NULL
```

gets(str)与scanf(“%s”,str)的区别：

* **gets(str)允许输入的字符串含有空格**

* **scanf(“%s”,str)不允许含有空格**

==**注意**：由于scanf()和gets()无法知道字符串s大小，必须遇到换行符或读到文件结尾为止才接收输入，因此容易导致字符数组越界(缓冲区溢出)的情况。而fgets()可以解决越界的情况==

```c
	char str[100];
	printf("请输入str: ");
	gets(str);
	printf("str = %s\n", str);
```

### （2）fgets 函数：标准输入

```c
#include <stdio.h>
char *fgets(char *s, int size, FILE *stream);
功能：从stream指定的文件内读入字符，保存到s所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\0' 作为字符串结束。
参数：
	s：字符串
	size：指定最大读取字符串的长度（size - 1）
	stream：文件指针，如果读键盘输入的字符串，固定写为stdin
返回值：
	成功：成功读取的字符串
	读到文件尾或出错： NULL
```

（1）fgets() 在读取一个用户通过键盘输入的字符串的时候，同时把用户输入的回车也做为字符串的一部分。

（2）通过 scanf() 和 gets() 输入一个字符串的时候，不包含结尾的“\n”，但通过 fgets 结尾多了“\n”。

（3）fgets() 函数是安全的，不存在缓冲区溢出的问题。

```c
	char str[100];
	printf("请输入str: ");
	fgets(str, sizeof(str), stdin);
	printf("str = \"%s\"\n", str);
```

### （3）puts 函数：标准输出

```c
#include <stdio.h>
int puts(const char *s);
功能：标准设备输出s字符串，在输出完成后自动输出一个'\n'。
参数：
	s：字符串首地址
返回值：
	成功：非负数
	失败：-1
```

```c
#include <stdio.h>
int main()
{
	printf("hello world");
	puts("hello world");

	return 0;
}
```

### （4）fputs 函数：标准输出

```c
#include <stdio.h>
int fputs(const char * str, FILE * stream);
功能：将str所指定的字符串写入到stream指定的文件中， 字符串结束符 '\0'  不写入文件。 
参数：
	str：字符串
	stream：文件指针，如果把字符串输出到屏幕，固定写为stdout
返回值：
	成功：0
	失败：-1
```

==**fputs()是puts()的区别**：puts()在输出完成时会自动输出一个换行符'\n'，而fputs()不会自动输出一个'\n'。==

### （5）strlen 函数：统计字符串长度

```c
#include <string.h>
size_t strlen(const char *s);
功能：计算指定指定字符串s的长度，不包含字符串结束符‘\0’
参数：
s：字符串首地址
返回值：字符串s的长度，size_t为unsigned int类型
```

* **==strlen 统计字符的长度，包括空格，但是不统计 ’ \0 ‘==**
* **==sizeof 除了统计字符串长度，还会统计\0，统计整个数组占用的内存大小==**

```c
	char str1[32] = "hello world";
	//strlen统计字符的长度
	printf("%d\n", strlen(str1));//11个字符 包括空格，但是不统计\0
	printf("%d\n", sizeof(str1));//32 统计整个数组占用的内存大小

	char str2[] = "hello world";
	//strlen统计字符的长度
	printf("%d\n", strlen(str2));//11个字符 包括空格，但是不统计\0
	printf("%d\n", sizeof(str2));//12 除了统计字符串长度，还会统计\0，统计整个数组占用的内存大小

	char str3[] = "hello\0world";
	//strlen统计字符的长度
	printf("%d\n", strlen(str3));//5  遇到\0就统计结束
	printf("%d\n", sizeof(str3));//12  10+2个\0
```

### （6）strcpy 函数：字符串拷贝

​	**==给字符数组赋值，需要利用 strcpy 函数或 strncpy 函数，遇到\0拷贝结束，字符串处理函数都有这个性质==**

```c
#include <string.h>
char *strcpy(char *dest, const char *src);             string copy
功能：把src所指向的字符串复制到dest所指向的空间中，'\0'也会拷贝过去
参数：
	dest：目的字符串首地址
	src：源字符首地址
返回值：
	成功：返回dest字符串的首地址
	失败：NULL
```

==注意：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。==

```c
	char dest[20] = "123456789";
	char src[] = "hello world";
	strcpy(dest, src);
	printf("%s\n", dest);
```

```c
void test01()
{
	char buf[32] = { 0 };
	
	//给字符数组赋值 需要利用strcpy函数
	//buf = "hello world";//不可以直接=赋值
	strcpy(buf, "hello world");//  \0也会拷贝到目标字符串中
	printf("%s\n", buf);

	strcpy(buf, "hello\0world");// 遇到\0拷贝结束，字符串处理函数都有这个性质
	printf("%s\n", buf);

	char buf2[10] = { 0 };
	//strcpy(buf2, "hellp world");//注意：原字符串比目标的长度长，程序奔溃
	//printf("%s\n", buf2);
}
```

### （7）strncpy 函数：字符串拷贝

​	**==给字符数组赋值，需要利用 strcpy 函数或 strncpy 函数，遇到\0拷贝结束，字符串处理函数都有这个性质==**

```c
#include <string.h>
char *strncpy(char *dest, const char *src, size_t n);
功能：把src指向字符串的前n个字符复制到dest所指向的空间中，是否拷贝结束符看指定的长度是否包含'\0'。
参数：
	dest：目的字符串首地址
	src：源字符首地址
	n：指定需要拷贝字符串个数
返回值：
	成功：返回dest字符串的首地址
	失败：NULL
```

```c
	char dest[20] ;
	char src[] = "hello world";

	strncpy(dest, src, 5);
	printf("%s\n", dest);

	dest[5] = '\0';
	printf("%s\n", dest);
```

```c
void test02()
{
	char buf[32] = { 0 };
	strncpy(buf, "hello world", 8);//第一个参数buf是首地址
	printf("%s\n", buf);//hello wo
	
	char buf2[32] = { 0 };
	strncpy(buf2, "hello\0world", 8);//只打印hello 遇到\0拷贝结束，字符串处理函数都有这个性质
	printf("%s\n", buf2);//hello wo
}
```

### （8）strcat 函数：字符串拼接

```c
#include <string.h>
char *strcat(char *dest, const char *src);       string connect
功能：将src字符串连接到dest的尾部，‘\0’也会追加过去
参数：
	dest：目的字符串首地址
	src：源字符首地址
返回值：
	成功：返回dest字符串的首地址
	失败：NULL
```

```c
	char str[20] = "123";
	char *src = "hello world";
	printf("%s\n", strcat(str, src));
```

```c
void test03()
{
	char buf1[32] = "hello";
	char buf2[32] = " world";

	strcat(buf1, buf2);
	printf("buf1=%s\n", buf1);
	printf("buf2=%s\n", buf2);
}
```

### （9）strncat 函数：字符串拼接

```c
#include <string.h>
char *strncat(char *dest, const char *src, size_t n);
功能：将src字符串前n个字符连接到dest的尾部，‘\0’也会追加过去
参数：
	dest：目的字符串首地址
	src：源字符首地址
	n：指定需要追加字符串个数
返回值：
	成功：返回dest字符串的首地址
	失败：NULL
```

```c
	char str[20] = "123";
	char *src = "hello world";
	printf("%s\n", strncat(str, src, 5));
```

```c
void test04()
{
	char buf1[32] = "hello";
	char buf2[32] = " world";

	strncat(buf1, buf2, 3);
	printf("buf1=%s\n", buf1);//hello wo
	printf("buf2=%s\n", buf2);// world
}
```

### （10）strcmp 函数：字符串比较

```c
#include <string.h>
int strcmp(const char *s1, const char *s2);        string compare
功能：比较 s1 和 s2 的大小，比较的是字符ASCII码大小，一个一个字符进行对比。
参数：
	s1：字符串1首地址
	s2：字符串2首地址
返回值：
	相等：0
	大于：>0
	小于：<0
```

```c
	char *str1 = "hello world";
	char *str2 = "hello mike";

	if (strcmp(str1, str2) == 0)
	{
		printf("str1==str2\n");
	}
	else if (strcmp(str1, str2) > 0)
	{
		printf("str1>str2\n");
	}
	else
	{
		printf("str1<str2\n");
	}
```

```c
void test05()
{
	char buf1[32] = "hello";
	printf("buf1=%s\n", buf1);
	printf("请输入一个字符:\n");

	char buf2[32] = { 0 };
	fgets(buf2, sizeof(buf2), stdin);//fgets()函数输入结束按回车时，这个回车也会读入字符串中
	
    //将buf2的\n改为\0
	buf2[strlen(buf2) - 1] = '\0';//去掉fgets()函数多读入的一个'\n'

	if (strcmp(buf1, buf2) == 0)
	{
		printf("buf1等于buf2\n");//输入hello即为相等

	}
	else if (strcmp(buf1, buf2) == 1)
	{
		printf("buf1大于buf2\n");
	}
	else if (strcmp(buf1, buf2) == -1)
	{
		printf("buf1小于buf2\n");
	}
}
```

### （11）strncmp 函数：字符串比较

```c
#include <string.h>
int strncmp(const char *s1, const char *s2, size_t n);
功能：比较 s1 和 s2 前n个字符的大小，比较的是字符ASCII码大小。
参数：
	s1：字符串1首地址
	s2：字符串2首地址
	n：指定比较字符串的数量
返回值：
	相等：0
	大于： > 0
	小于： < 0
```

```c
void test06()
{
	char buf1[32] = "hello";
	printf("buf1=%s\n", buf1);

	printf("请输入一个字符:\n");

	char buf2[32] = { 0 };
	fgets(buf2, sizeof(buf2), stdin);//fgets()函数输入结束按回车时，这个回车也会读入字符串中
	//将buf2的\n改为\0
	buf2[strlen(buf2) - 1] = '\0';//去掉fgets()函数多读入的一个'\n'

	if (strncmp(buf1, buf2, 5) == 0)
	{
		printf("buf1等于buf2\n");//输入hello即为相等

	}
	else if (strncmp(buf1, buf2, 5) == 1)
	{
		printf("buf1大于buf2\n");
	}
	else if (strncmp(buf1, buf2, 5) == -1)
	{
		printf("buf1小于buf2\n");
	}
}
```

```c
void test06()
{
	printf("请输入一个季节：sping summer autumn winter\n");
	char buf[32] = { 0 };
	fgets(buf, sizeof(buf), stdin);//fgets()函数输入结束按回车时，这个回车也会读入字符串中
	buf[strlen(buf) - 1] = '\0';//去掉fgets()函数多读入的一个'\n'
	if (strncmp(buf, "spring", 6) == 0)
	{
		printf("春天\n");
	}
	else if (strncmp(buf, "summer", 6) == 0)
	{
		printf("夏天\n");
	}
	else if (strncmp(buf, "autumn", 6) == 0)
	{
		printf("秋天\n");
	}
	else if (strncmp(buf, "winter", 6) == 0)
	{
		printf("冬天\n");
	}
}
```

### （12）sprintf 函数：格式化字符串拼接

```c
#include <stdio.h>
int sprintf(char *_CRT_SECURE_NO_WARNINGS, const char *format, ...);
功能：根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 '\0'  为止。
参数：
	str：字符串首地址
	format：字符串格式，用法和printf()一样
返回值：
	成功：实际格式化的字符个数
	失败： - 1
```

```c
	char dst[100] = { 0 };
	int a = 10;
	char src[] = "hello world";
	printf("a = %d, src = %s", a, src);
	printf("\n");

	int len = sprintf(dst, "a = %d, src = %s", a, src);
	printf("dst = \" %s\"\n", dst);
	printf("len = %d\n", len);
```

```c
void test07()
{
	int year = 2019;
	int month = 12;
	int day = 16;
	char buf[32] = { 0 };

	//参数1：目标  参数2：格式化信息  参数3：不定参数，有很多个
	sprintf(buf, "%d年%d月%d日", year, month, day);//把整数转换成字符串

	printf("buf=%s\n", buf);
}
```

### （13）sscanf 函数：格式化字符串拆分

```c
#include <stdio.h>
int sscanf(const char *str, const char *format, ...);
功能：从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。
参数：
	str：指定的字符串首地址
	format：字符串格式，用法和scanf()一样
返回值：
	成功：参数数目，成功转换的值的个数
	失败： - 1
```

```c
	char src[] = "a=10, b=20";
	int a;
	int b;
	sscanf(src, "a=%d,  b=%d", &a, &b);
	printf("a:%d, b:%d\n", a, b);
```

```c
void test08()
{
	char msg[128] = "phone:13693594039;2019/12/16;该还钱了";

	long long phoneNum = 0;
	int year = 0;
	int month = 0;
	int day = 0;
	char text[64] = { 0 };

    //后面的参数要取地址，text名字就代表首地址
	sscanf(msg, "phone:%lld;%d/%d/%d;%s", &phoneNum, &year, &month, &day, text);

	printf("%lld\n", phoneNum);
	printf("%d\n", year);
	printf("%d\n", month);
	printf("%d\n", day);
	printf("%s\n", text);
}
```

### （14）strchr 函数：查找字符位置

```c
#include <string.h>
char *strchr(const char *s, int c);    string char
功能：在字符串s中查找字母c出现的位置
参数：
	s：字符串首地址
	c：匹配字母(字符)
返回值：
	成功：返回第一次出现的c地址
	失败：NULL
```

```c
	char src[] = "ddda123abcd";
	char *p = strchr(src, 'a');
	printf("p = %s\n", p);
```

```c
void test09()
{
	char buf[32] = "zhangtao@sina.com";

	char* ret = strchr(buf, '@');//位置从0开始数
	if (ret == NULL)
	{
		printf("未找到@符号\n");
	}
	else
	{
		printf("找到了@符号，位置在：%d\n", ret - buf);
	}
}
```

### （15）strstr 函数：查找字符串位置

```c
#include <string.h>
char *strstr(const char *haystack, const char *needle);     string string
功能：在字符串haystack中查找字符串needle出现的位置
参数：
	haystack：源字符串首地址
	needle：匹配字符串首地址
返回值：
	成功：返回第一次出现的needle地址
	失败：NULL
```

```c
	char src[] = "ddddabcd123abcd333abcd";
	char *p = strstr(src, "abcd");
	printf("p = %s\n", p);
```

```c
void test10()
{
	char* str = "abcdefgabc";//位置从0开始数
	char* ret = strstr(str, "de");
	if (ret == NULL)
	{
		printf("未找到子串\n");
	}
	else
	{
		printf("找到子串_位置：%d\n", ret - str);
	}
}
```

### （16）strtok 函数：分割字符串

```c
#include <string.h>
char *strtok(char *str, const char *delim);
功能：来将字符串分割成一个个片段。当strtok()在参数s的字符串中发现参数delim中包含的分割字符时, 则会将该字符改为\0 字符，当连续出现多个时只替换第一个为\0。
参数：
	str：指向欲分割的字符串
	delim：为分割字符串中包含的所有字符
返回值：
	成功：分割后字符串首地址
	失败：NULL
```

在第一次调用时：strtok()必需给予参数s字符串

往后的调用则将参数s设置成NULL，每次调用成功则返回指向被分割出片段的指针

```c
	char a[100] = "adc*fvcv*ebcy*hghbdfg*casdert";
	char *s = strtok(a, "*");//将"*"分割的子串取出
	while (s != NULL)
	{
		printf("%s\n", s);
		s = strtok(NULL, "*");
	}
```

```c
void test12()
{
#if 0   
	char buf[1024] = "张三:李四:王五:哈哈:呵呵";
	char* names[64] = { 0 };//"张三"的返回结果是char*

	////char* name1 = strtok(buf, ":");
	////printf("%s\n", name1);//张三

	////name1 = strtok(NULL, ":");//从第二次分割开始，参数1填为NULL
	////printf("%s\n", name1);//李四

	int i = 0;//数组中的下标
	names[i] = strtok(buf, ":");

	while (names[i] != NULL)//数组中没有元素时才放进去
	{
		i++;
		names[i] = strtok(NULL, ":");//从第二次分割开始，参数1填为NULL
	}

	//遍历数组
	i = 0;
	while (names[i] != NULL)
	{
		printf("%s\n", names[i++]);
	}

#else
    //优化上述代码
    char buf[1024] = "张三:李四:王五:哈哈:呵呵";
	char* names[64] = { buf,NULL };
	int i = 0;

	//将第一次分割和其他次分割写在一起了
	while ((names[i++] = strtok(names[i], ":")) != NULL)//有值不为空才执行这段代码
	{
		//i++;
	}

	//遍历数组
	i = 0;
	while (names[i] != NULL)
	{
		printf("%s\n", names[i++]);
	}
#endif    
}
```

```c
//strtok扩展
void test14()
{
	char buf[1024] = "haha?hehe:lala####hehe*****xixi!!!aaaa";

	char* words[64] = { buf,NULL };
	int i = 0;
	while ((words[i++] = strtok(words[i], "?:#*!")) != NULL)
	{
		//i++;
	}

	//遍历数组
	i = 0;
	while (words[i] != NULL)
	{
		printf("%s\n", words[i++]);
	}
}
```

### （17）atoi 函数：转换字符串

```c
#include <stdlib.h>
int atoi(const char *nptr);
功能：atoi()会扫描nptr字符串，跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符('\0')才结束转换，并将结果返回返回值。
参数：
	nptr：待转换的字符串
返回值：成功转换后整数
```

类似的函数有：

* **atof()**：把一个小数形式的字符串转化为一个浮点数。

* **atol()**：将一个字符串转化为long类型

```c
	char str1[] = "-10";
	int num1 = atoi(str1);
	printf("num1 = %d\n", num1);

	char str2[] = "0.123";
	double num2 = atof(str2);
	printf("num2 = %lf\n", num2);
```

* atoi将字符串中的数字转成int型数字，比如将"123abc"转成整型123
* atof将字符串中的数字转成float型数字
* atol将字符串中的数字转成long型数字

```c
void test15()
{
	int num = 0;
	char buf[] = "123abc1234";//遇到不匹配的字母就结束匹配
	num = atoi(buf);
	printf("num=%d\n", num);

	//sscanf也可以做到 字符串转数字，如果第一个匹配失败，则结束匹配
	sscanf("abcd1234", "%*[a-z]%d", &num);//%*代表过滤的意思，%*[a-z]过滤掉a-z的信息
	printf("num=%d\n", num);

	int a = 0;
	int b = 0;
	sscanf("1234 5678", "%d %d", &a, &b);
	printf("a=%d\n", a);
	printf("b=%d\n", b);
}
```

## 5.7 字符串相关案例：屏蔽禁语

上单 你真SB SB SB   ---->   上单 你真** ** **

```c
void test11()
{
	char buf[1024] = { 0 };

	fgets(buf, sizeof(buf), stdin);//fgets()函数输入结束按回车时，这个回车也会读入字符串中
	//将buf中\n改为\0
	buf[strlen(buf) - 1] = '\0';//去掉fgets()函数多读入的一个'\n'

	char* p = buf;//创建临时指针 遍历字符串信息
#if 0
	while (1)
	{
		//上单 你真SB SB SB
		char* ret = strstr(p, "SB");
		if (ret != NULL)
		{
			//找到禁语情况
			strncpy(ret, "**", 2);
			p = ret + 2;
		}
		else
		{
			break;//退出循环
		}
	}
	printf("%s\n", buf);
#else 
	//优化代码
	char* ret = NULL;
	while (ret = strstr(p, "SB"))//找到了括号里面就为真
	{
		strncpy(ret,"**", 2);
		p = ret + 2;
	}
	printf("%s\n", buf);
#endif
}
```



# 6 函数

​	从函数定义的角度看，可以分为两类：

（1）**系统函数**：也就是库函数，由编译器提供的，用户直接使用他们。

（2）**用户自定义函数**：用于解决用户的专门需要。

## 6.1 函数的定义、调用和声明

1、函数的定义：

```c
	返回类型 函数名(形式参数列表)
	{
		数据定义部分;
		执行语句部分;
	}
```

```c
//1、函数的定义
int add(int num1, int num2)//num1和num2只是形式上的参数，并没有实际的值，因此称为形参
{
	int sum = num1 + num2;
	return sum;
}
```

2、函数的调用：

```c
	函数的调用
	语法：函数名(参数1，参数2);
```

```c
//void代表函数体不需要返回值，不用写return，要写也可以写return;
void test01()
{
	//2、函数的调用
	//语法：函数名(参数1，参数2);
	int num1 = 10;
	int num2 = 20;
	int sum = add(num1, num2);//num1和num2有实际的值，叫做实参
	//当函数在调用的时候，实参和形参之间建立了关系
	
	printf("sum=%d\n", sum);

	return;//可写可不写
}
```

3、函数的声明：

```c
	返回类型 函数名(形式参数列表);
```

```c
//3、函数的声明
//如果函数的定义在使用的后面，则需要提前声明，告诉编译器后面有这个函数，不要报错
//函数的定义只能有一次，但函数的声明可以有多次
int get_Max(int num1, int num2);

void test02()
{
	int num1 = 100;
	int num2 = 200;

	int max = get_Max(num1, num2);
	printf("max=%d\n", max);
}
```

## 6.2 函数的四种常见形式

1、无参无返：

```c
//1、无参无返
void func1()
{
	printf("func1调用\n");
}

//无参无返调用
void test01()
{
	func1();
}
```

2、有参无返：

```c
//2、有参无返
void func2(int num)
{
	printf("func2调用num=%d\n", num);
}

//有参无返调用
void test02()
{
	func2(1000);
}
```

3、无参有返：

```c
//3、无参有返
int func3()
{
	printf("func3调用\n");
	return 2000;
}

//无参有返调用
void test03()
{
	int ret = func3();//ret = result
	printf("ret=%d\n", ret);
}
```

4、有参有返：

```c
//4、有参有返
int func4(int num)
{
	printf("func4调用num=%d\n", num);
	return num + 100;
}

//4、有参有返调用
void test04()
{
	ret = func4(100);
	printf("ret=%d\n", ret);
}
```

## 6.3 return 和 exit(0) 的区别

**主要区别：**return退出当前函数  exit(0)退出整个程序

```c
//return退出当前函数  exit(0)退出整个程序
void test01()
{
	printf("01\n");
	printf("02\n");
	printf("03\n");

	//return;//退出当前函数
	exit(0);//0代表一个退出值，退出整个程序

	printf("04\n");
	printf("05\n");

}
```

## 6.4 函数的分文件编写

### 6.4.1 分文件编程

* 把函数声明放在头文件xxx.h中，在主函数中包含相应头文件

* 在头文件对应的xxx.c中实现xxx.h声明的函数

![img](file:///C:\Users\wenca\AppData\Local\Temp\ksohtml\wpsFE75.tmp.jpg)

### 6.4.2 防止头文件重复包含

​	当一个项目比较大时，往往都是分文件，这时候有可能不小心把同一个头文件 include 多次，或者头文件嵌套包含。

a.h 中包含 b.h ：

```c
#include "b.h"
```

b.h 中包含 a.h：

```c
#include "a.h"
```

main.c 中使用其中头文件：

```c
#include "a.h"

int main()
{
	return 0;
}
```

编译上面的例子，会出现如下错误：

![img](file:///C:\Users\wenca\AppData\Local\Temp\ksohtml\wps6947.tmp.jpg)

​	==**为了避免同一个文件被include多次，C/C++中有两种方式，一种是 #ifndef 方式，一种是 #pragma once 方式。**==

#### （1）==#ifndef 方式==

```c
#ifndef __SOMEFILE_H__
#define __SOMEFILE_H__

// 声明语句

#endif
```

#### （2）==#pragma once 方式==

```c
#pragma once

// 声明语句
```



## 6.5 随机数种子：时间戳

```c
#include <time.h>
time_t time(time_t *t);
功能：获取当前系统时间
参数：常设置为NULL
返回值：当前系统时间, time_t 相当于long类型，单位为毫秒
```

```c
#include <stdlib.h>
void srand(unsigned int seed);
功能：用来设置rand()产生随机数时的随机种子
参数：如果每次seed相等，rand()产生随机数相等
返回值：无
```

```c
#include <stdlib.h>
int rand(void);
功能：返回一个随机数值
参数：无
返回值：随机数
```

注意：一定要添加头文件#include <time.h>

1、产生随机数：

```c
	int num = rand() % 100 + 1;//1~100之间的随机数
```

2、添加随机数种子（2种写法）：==随机数种子只需要设置一次即可==

```c
	//第一种写法：
	srand((unsigned int)time(NULL));

	//第二种写法：
	srand((size_t)time(NULL));
```

 ```c
 	//添加随机数种子，让该数真正随机
 	//time(NULL)根据1970年1月1日0:0:0至今的秒数
 	//(unsigned int)表示强制类型转换
 	//在使用的时候需要包含一个头文件   #include<time.h>
 	//如果还有其他地方也要随机数，只需要设置一次足以
 	srand((unsigned int)time(NULL));
 
 	//1、让系统产生随机数
 	int num = rand() % 100 + 1;//1~100之间的随机数
 ```



## 6.6 函数案例1：获取随机数

获取一个数字，并且返回给用户，区间由用户传递。

```c
int getRandom(int min, int max)
{
	int random = 0;
	random = rand() % (max - min + 1) + min;//1~10之间的数字
	return random;
}

void test01()
{
	//随机数种子  time(NULL)表示时间戳
	printf("time(NULL)=%d\n", time(NULL));//time(NULL)表示从1970年到现在的秒数
	
	//根据时间戳来获取随机数
	srand((unsigned int)time(NULL));
	srand((size_t)time(NULL));//和上面是一样的
	
	int random = getRandom(30, 100);
	printf("random=%d\n", random);
}
```

## 6.7 函数案例2：打字游戏

让系统随机产生英文字母（个数15），我们输入字母，如果输入有误输出 ' - ' ，输出正确，正常输出

```c
void test01()
{
	//随机数种子
	srand((unsigned int)time(NULL));
    
	//1、创建存放15个字母的数组
	char buf[NUM + 1] = { 0 };//还有一个'\0'
    
	//2、产生随机字母
	for (int i = 0; i < NUM; i++)
	{
		//97~97+25   a+0~a+25
		buf[i] = rand() % 26 + 'a';
	}
	printf("%s\n", buf);
	
	int count = 0;//统计正确的个数
	int startTime = 0;//开始输入的时间
	int endTime = 0;//结束输入的时间

	//3、用户输入数据
	for (int i = 0; i < NUM; i++)
	{
		char ch = _getch();//_getch输入一个字符，字符不会回显（不会直接显示到屏幕中） //getchar();	
		if (i == 0)
		{
			startTime = time(NULL);//开始计时
		}

		if (ch == buf[i])
		{
			printf("%c", ch);//让字符显示
			count++;//正确的个数
		}
		else
		{
			printf("%c", '-');
		}
	}
	printf("\n");
	endTime = time(NULL);//结束计时
	printf("正确率为：%.2f%%\n", (double)count / (double)NUM * 100);//前面%.2f表示输出两个小数，%%表示输出一个%号
	printf("所用时间为%ds\n", endTime - startTime);
}
```

# 7 指针

## 7.1 计算机组成

### 7.1.1 内存

**内存**含义：

* **存储器**：计算机的组成中，用来存储程序和数据，辅助CPU进行运算处理的重要部分。

* **内存**：内部存贮器，暂存程序/数据——掉电丢失 SRAM、DRAM、DDR、DDR2、DDR3。

* **外存**：外部存储器，长时间保存程序/数据—掉电不丢ROM、ERRROM、FLASH（NAND、NOR）、硬盘、光盘。

**==内存是沟通CPU与硬盘的桥梁：==**

* 暂存放CPU中的运算数据

* 暂存与硬盘等外部存储器交换的数据

**==寄存器是沟通CPU和内存的桥梁==**

![2.9 CPU与寄存器](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.9 CPU与寄存器.png)

### 7.1.2 物理存储器和存储地址空间

​	有关内存的两个概念：**物理存储器和存储地址空间**。

**物理存储器**：实际存在的具体存储器芯片。

* 主板上装插的**内存条**

* 显示卡上的**显示RAM芯片**

* 各种适配卡上的**RAM芯片和ROM芯片**

**存储地址空间**：对存储器编码的范围。==我们在软件上常说的内存是指这一层含义。==

* **编码**：对每个物理存储单元（一个字节）分配一个号码

* **寻址**：可以根据分配的号码找到相应的存储单元，完成数据的读写

### 7.1.3 内存地址

​	==将内存抽象成一个很大的一维字符数组，编码就是对内存的每一个字节分配一个32位或64位的编号（与32位或者64位处理器相关），这个内存编号我们称之为内存地址。==

**内存中的每一个数据都会分配相应的地址：**

* char：占一个字节分配一个地址

* int：占四个字节分配四个地址

* float、struct、函数、数组等

![img](file:///C:\Users\wenca\AppData\Local\Temp\ksohtml\wps259.tmp.jpg)

### 7.1.4 指针和指针变量

* **内存区的每一个字节都有一个编号，这就是“地址”。**

* 如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给这个变量分配内存单元，并确定它的内存地址(编号)

* 指针的实质就是内存“地址”。指针就是地址，地址就是指针。

* **指针是内存单元的编号，指针变量是存放地址的变量。**

* 通常我们叙述时会把指针变量简称为指针，实际他们含义并不一样。

![img](file:///C:\Users\wenca\AppData\Local\Temp\ksohtml\wps8EEC.tmp.jpg)

## 7.2 指针的基本使用

### 7.2.1 指针的定义、使用和大小

![2.58 指针的基本使用](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.58 指针的基本使用.png)

```c
//1、指针的基本使用
void test01()
{
	//创建普通变量
	int a = 10;

	//创建指针变量
	int* p;

	//指针变量和普通变量建立关系
	p = &a;

	//通过指针变量来操作内存
	*p = 20;

	printf("a=%d\n", a);
	printf("*p=%d\n", *p);//解引用
	printf("%d\n", p);//利用指针变量看地址  %p也可以打印地址，以十六进制方式打印
	printf("%d\n", &a);//直接看地址

	//注意：使用指针的时候，当*和&符号同时出现，从右往左依次抵消
	//*p为什么是a   p==&a   *p==*&a==a
}
```

2、**指针的大小**：

* ==指针在32位操作系统下 都是**4个字节**的大小==
* 指针在64位操作系统下 都是8个字节的大小

```c
void test02()
{
	//指针在32位操作系统下 都是4个字节的大小
	//指针在64位操作系统下 都是8个字节的大小
	printf("sizeof int* = %d\n", sizeof(int*));//4个字节
	printf("sizeof char* = %d\n", sizeof(char*));//4个字节
	printf("sizeof double* = %d\n", sizeof(double*));//4个字节
	printf("sizeof short* = %d\n", sizeof(short*));//4个字节
}
```

### 7.2.2 空指针和野指针

（1）**空指针**：指针变量指向地址编号为0的地址，NULL在底层定义的是一个常量0。

* ==**不可以访问空指针指向的内容，但是可以访问空指针。即可以直接输出，但不能解引用。**==
* **==内存地址编号0~255之间被系统占用，不可以访问，系统给我们分配内存地址的时候也不会给我们分配这块地址。==**

​	==空指针的用法：对指针进行初始化。在创建指针变量时，可以给指针初始化为NULL。==

（2）**野指针**：指向非法的内存空间的指针。

* **野指针不会直接引发错误，操作野指针指向的内存区域才会出问题**。
* **一般定义指针变量时，直接让他指向空指针，防止其变成野指针**。

```c
void test02()
{
	//指针变量  指向非法的内存空间
	//int* p = 0xffff;
	//printf("%d\n", *p);//不可以访问野指针指向的内存空间
}

void test03()
{
	//int* p;//指针变量未初始化，也属于野指针
	//printf("%d\n", *p);//vs下不可以运行，gcc可以编译通过，但是运行奔溃
}
```

### 7.2.3 万能指针 void*

​	**void *指针可以指向任意变量的内存空间：**

* ==指向变量时，最好转换为void*==
* ==使用指针变量指向的内存时，转换为变量原来的类型==

```c
	void *p = NULL;

	int a = 10;
	p = (void *)&a; //指向变量时，最好转换为void *

	//使用指针变量指向的内存时，转换为int *
	*( (int *)p ) = 11;
	printf("a = %d\n", a);
```

### 7.2.4 const 修饰的指针变量

![2.61 const修饰指针变量](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.61 const修饰指针变量.png)

#### （1）const 修饰的 * ：常量指针

​	==指针指向的值不可以修改，指针指向可以修改==。     **const    *    常量  指针**

```c
void test01()
{
	int a = 10;
	const int* p = &a; //等价于int const* p=&a;

	//*p = 20;//报错，*p是只读的 指针指向的值不可以修改

	int b = 20;
	p = &b;//正确，指针指向可以修改
	printf("%d\n", *p);
}
```

#### （2）const 修饰的是 p ：指针常量

​	==指针指向的值可以改，指针的指向不可以修改==。       ***   const      指针  常量**

```c
void test02()   
{
	int a = 10;
	int* const p = &a;
	*p = 20;//正确 指针指向的值可以改

	int b = 100;
	//p = &b;//错误，指针的指向不可以修改
}
```

#### （3）const 修饰的 * 和 p 

​	==指针指向的值不可以改，指针的指向不可以改==

```c
void test03()
{
	int a = 10;
	const int* const p = &a;

	//*p = 100;//指针指向的值不可以改

	int b = 20;
	//p = &b;//指针的指向不可以改
}
```

### 7.2.5 不同类型指针区别

![2.62 不同类型指针区别](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.62 不同类型指针区别.png)

#### （1）==**步长不同**==： +1 之后字节跳跃数量不同

```c
void test01()
{
	char* p1 = NULL;
	printf("%d\n", p1);
	printf("%d\n", p1 + 1);

	int* p2 = NULL;
	printf("%d\n", p2);
	printf("%d\n", p2 + 1);

	int* p3 = NULL;
	printf("%d\n", p3);
	printf("%d\n", p3 + 1);
}
```

#### （2）**==解引用时取出的字节数不同==**

```c
void test02()
{
	int num = 0x01020304;//16进制的4字节数据

	int* p1 = &num;
	printf("*p1 = %#x\n", *p1);//输出0x01020304

	short* p2 = &num;
	printf("*p2 = %#x\n", *p2);//输出0x0304

	char* p3 = &num;
	printf("*p3 = %#x\n", *p3);//输出0x04
}
```

## 7.3 指针和数组

### 7.3.1 通过移动指针来遍历数组（三种方式）

​	==**数组名arr指向数组首元素的地址，也可以当成一个指针去使用**==

```c
void test01()
{
	int arr[5] = { 1,2,3,4,5 };
	printf("sizeof arr = %d\n", sizeof(arr));//20

	//数组名arr指向数组首元素的地址，也可以当成一个指针去使用
	printf("%d\n", arr);
	printf("%d\n", arr + 1);//该指针是int*

	//1、访问第一个元素
	printf("第一个元素为：%d\n", arr[0]);//符合我们的思想，本质还是下面的写法进行解引用
	printf("第一个元素为：%d\n", *arr);//把数组名当作一个指针来使用，解引用就得到第一个数据

	//2、访问第二个元素
	printf("第二个元素为：%d\n", arr[1]);//符合我们的思想，本质还是下面的写法进行解引用
	printf("第二个元素为：%d\n", *(arr+1));//把数组名当作一个指针来使用，解引用就得到第一个数据

	//3、[]本质：就是*()的简写，看上面的代码
	printf("第二个元素为：%d\n", *(1 + arr));
	printf("第二个元素为：%d\n", 1[arr]);//不推荐用

	//4、遍历数组
	for (int i = 0; i < 5; i++)
	{
		printf("%d", arr[i]);
		printf("%d", *(arr + 1));
		printf("%d", i[arr]);
	}
	printf("\n");

	//5、arr为什么可以作为首元素的地址？
	//&arr[0]   ->    &*(arr+0)  ->  &*arr  ->  arr

	//6、arr一定是指向首元素的地址的指针吗？
    //不一定 比如特殊情况，对sizeof(arr)
}
```

### 7.3.2 通过指针操作数组

#### （1）指针变量 p 和数组 arr 的区别

* sizeof (p) 代表指针变量所占用的内存，为4
* sizeof (arr) 代表整个数组所占用的内存，为数组的类型 * 数组的个数

```c
	printf("sizeof p = %d\n", sizeof(p));//4
	printf("sizeof arr = %d\n", sizeof(arr));//20
```

#### （2）指针变量访问数组的时候，下标可以为负数

```c
void test02()
{
	int arr[5] = { 1,2,3,4,5 };
	int* p = arr;
	for (int i = 0; i < 5; i++)
	{
		//printf("%d\n", p[i]);
		printf("%d\n", *(p + i));
	}

	//访问数组的时候，下标可以为负数
	int* p2 = &arr[2];//3
	printf("*p2 = %d\n", *p2);//3
	printf("*p2 = %d\n", p2[-1]);//2   当-1时还有数组的值
	printf("*p2 = %d\n", *(p2 - 1));//上面的一行代码等价于这行代码
}
```

#### （3）指针变量的复合运算

```c
void test03()
{
	int arr[5] = { 10,20,30,40,50 };
	int* p = arr;
    
	//难点：*p++和(*p)++和*(p++)都是先计算除++之外的值，最后再计算++这个运算符
	printf("%d\n", *p++);//10  先*p，后p++
	printf("%d\n", (*p)++);//20  先*p，后*p ++
	printf("%d\n", *(p++));//21  先*p，后p++
	printf("*p% = d\n", *p);

	for (int i = 0; i < 5; i++)//10 21 30 40 50
	{
		printf("%d\n", arr[i]);
	}
}
```

​	==**两个指针相加、相乘、相除无意义。但相减有意义，相当于在数组中相差几个位置。**==

```c
void test01()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p1 = arr;
	int* p2 = &arr[4];

	//两个指针相加、相乘、相除无意义，但相减有意义
	printf("p1+p2=%d\n", (int)p1 + (int)p2);

	//两个指针相减有意义  相当于在数组中相差几个位置
	printf("p2-p1=%d\n", (int)p2 - (int)p1);//4
```

### 7.3.3 指针数组

​	**指针数组**：==数组里面的元素都是地址的数组==

```c
void test01()
{
	int num1 = 10;
	int num2 = 20;
	int num3 = 30;
	int num4 = 40;

    //指针数组的定义：
	int* arr[4] = { &num1,&num2,&num3,&num4 };
	int len = sizeof(arr) / sizeof(int*);
    
    //遍历数组：
	for (int i = 0; i < len; i++)
	{
		printf("%d\n", *arr[i]);//推荐写法
		//printf("%d\n", **(arr + i));//不推荐用
	}
}
```

​	**==用 %s 可以直接打印字符串，字符串" "里面的东西会返回第一个字符的地址。==**

```c
void test02()
{
	//""里面的东西会返回第一个字符的地址
	char* arr[4] = { "aaa","bbb","ccc","ddd" };

	int len = sizeof(arr) / sizeof(char*);
	for (int i = 0; i < len; i++)
	{
		printf("%s\n", arr[i]);//从第一个元素输出，输出到遇到\0结束
	}
}
```

## 7.4 二级指针

二级指针：**指向指针的指针**

```c
void test01()
{
	int num = 10;
	int* p = &num;
	int** pp = &p;

	printf("&num = %d\n", &num);//num的地址
	printf("p = %d\n", p);//p的值就是num的地址

	printf("*p = %d\n", *p);//num的值
	printf("num = %d\n", num);//num的值

	printf("&p = %d\n", &p);//p的地址
	printf("pp = %d\n", pp);//pp的值就是p的地址

	printf("*pp = %d\n", *pp);//等价于num的地址
	printf("**pp = %d\n", **pp);//num的值
}
```

## 7.5 指针和函数

### 7.5.1 参数的传递方式

#### （1）值传递：形参不可以修饰实参

![2.66 参数的传递方式_值传递](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.66 参数的传递方式_值传递.png)

```c
//交换两个数据
void mySwap(int num1, int num2)
{
	int temp = num1;
	num1 = num2;
	num2 = temp;

    //交换成功
	printf("num1=%d\n", num1);//20
	printf("num2=%d\n", num2);//10
}

void test01()
{
	int a = 10;
	int b = 20;
	mySwap(a, b);
    
	//未交换成功
	printf("a=%d\n", a);//10
	printf("b=%d\n", b);//20
}
```

#### （2）地址传递：形参可以修饰实参

![2.66 参数的传递方式_地址传递](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.66 参数的传递方式_地址传递.png)

```c
void mySwap2(int* p1, int* p2)
{
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;

    //交换成功
	printf("*p1=%d\n", *p1);//20
	printf("*p2=%d\n", *p2);//10
}

void test01()
{
	int a = 10;
	int b = 20;
	mySwap2(a, b);

	//交换成功
	printf("a=%d\n", a);//20
	printf("b=%d\n", b);//10
}
```

### 7.5.2 数组名作函数参数

​	==当数组名作函数参数的时候，会被退化为一个指针，指向数组中第一个元素的地址。==

```c
void printArray(int* arr, int len)
{
	for (int i = 0; i < len; i++)
	{
		printf("%d\n", arr[i]);
	}
    
    //代表的是指针变量所占用的内存
	printf("printArray sizeof arr=%d\n", sizeof(arr));//4
}

void test01()
{
	int arr[5] = { 1,2,3,4,5 };
	int len = sizeof(arr) / sizeof(int);
	printArray(arr, len);
    
    //代表的是整个数组所占用的内存
	printf("sizeof arr=%d\n", sizeof(arr));//20
}
```

```c
//这两个函数的写法等价
void setArray(int* arr, int len)
{
    
}
void setArray(int arr[], int len)
{
    
}
```

```c
//void setArray(int* arr, int len)
void setArray(int arr[], int len)//与上面等价，且更好理解
{
	for (int i = 0; i < len; i++)
	{
		scanf("%d", &arr[i]);
	}
}

void test02()
{
	int arr[5] = { 0 };
	int len = sizeof(arr) / sizeof(int);
	setArray(arr, len);

	printf("赋值后数组的结果为：\n");
	printArray(arr, len);
}
```

### 7.5.3 ==字符数组作函数参数==

```c
void setCharArray(char* arr, int len)
{
	printf("请对字符串进行赋值：\n");
	fgets(arr, len, stdin);//可以输入空格，同时也会把用户输入的回车当作字符串的一部分
}

int myStrlen(char buf[])
{
	int count = 0;
    //改进前的代码
	//while (buf[count] != '\0')
	//{
	//	count++;
	//}
	//return count;

    //改进后的代码：比较高效
	while (buf[count++] != '\0')//条件不满足后也会count+1
	{

	}
	return count - 1;
}

void changeArray(char arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		if (arr[i] >= 'a' && arr[i] <= 'z')
		{
			arr[i] -= 32;
		}
		else if (arr[i] >= 'A' && arr[i] <= 'Z')
		{
			arr[i] += 32;
		}
	}
}

void test01()
{
	char buf[1024] = { 0 };

	//1、定义一个函数，给buf进行赋值
	setCharArray(buf, sizeof(buf));//输出时会多产生一个换行，因为手动输入了一个换行

	//buf=hello world\n00000000
	//将\n改为\0，就可以防止多一个换行了
	buf[strlen(buf) - 1] = '\0';//因为fgets()输入完成按回车时，系统会把回车也读入到字符串中，因此要将这个回车去掉
	printf("buf=%s\n", buf);

	//2、自己实现strlen统计字符个数的函数
	int count =  myStrlen(buf);
	printf("strlen=%d\n", strlen(buf));
	printf("myStrlen=%d\n", count);

	//3、将字符进行大小写转换
	printf("转换前：%s\n", buf);

	changeArray(buf, count);
	printf("转换后：%s\n", buf);
}
```

### 7.5.4 指针作函数的返回值类型

```c
//指针作函数的返回值类型
int g_a = 1000;//全局变量

//写一个函数 功能：返回全局变量g_a的地址
int* getAddress()
{
	return &g_a;
}

void test01()
{
	int* p = getAddress();
	printf("g_a = %d\n", g_a);
	printf("*p = %d\n", *p);

	*p = 2000;
	printf("g_a = %d\n", g_a);
	printf("*p = %d\n", *p);
}
```

### 7.5.5 字符数组和字符串指针变量的区别

#### （1）字符串指针变量

* ==字符串常量位于常量区，不允许修改==
* ==字符串常量返回第一个字母的首地址==

```c
	char* str = "hello world";//等号右边是字符串常量，不允许修改
```

![2.71 字符数组和字符串指针变量的区别_字符串](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.71 字符数组和字符串指针变量的区别_字符串.png)

```c
void test01()
{
	//str记录右边字符串常量第一个字母的首地址，所以不允许修改
	//hello world存在常量区，不允许修改
	char* str = "hello world";//等号右边是字符串常量
	printf("%s\n", str);

	//str[0] = 'x';//报错，不允许修改
	printf("%s\n", str);
}
```

#### （2）字符数组

* 字符数组，允许修改，将等号右边复制出来一份，赋给等号左边str，所以str可以修改
* **==给字符数组赋值，需要用到 strcpy 函数或 strncpy 函数，遇到\0拷贝结束，字符串处理函数都有这个性质==**

![2.71 字符数组和字符串指针变量的区别_字符数组](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.71 字符数组和字符串指针变量的区别_字符数组.png)

```c
	char str[] = "hello world";//字符数组，允许修改
```

```c
void test02()
{
	//将等号右边复制出来一份，赋给等号左边str，所以str可以修改
	char str[] = "hello world";
	printf("%s\n", str);

	str[0] = 'x';
	printf("%s\n", str);
}
```

# 8 内存管理

## 8.1 作用域

### 8.1.1 普通局部变量

​	局部变量也叫auto自动变量(auto可写可不写)

```c
	//auto写不写是一样的
	//auto只能出现在{}内部
	auto int b = 10; 
```

* 定义形式：在{}里面定义的变量，称为局部变量

* 作用范围：离最近的{}里面可以使用

* 生命周期：最近的{}结束后，变量被释放

* 注意事项：==局部变量 未初始化 值是随机的 vs下不可以访问==；==普通全局变量未初始化，结果为0==

​	**在一个函数内定义，只在函数范围内有效；在复合语句中定义，只在复合语句中有效。**

```c
void test01()
{
	int a;
	//printf("%d\n", a);//值是随机的，不可以输出
	{
		int b = 10;
	}
	//printf("%d\n", b);//b超出了{}，不可以使用

	int c = 10;
	{
		int c = 20;
		printf("c=%d\n", c);//20  不同的作用域下有同名的时候，优先使用最近的{}内的变量，就近原则
	}
	printf("c=%d\n", c);//10  只能用外面这个10，别无选择
}
```

### 8.1.2 普通全局变量

* 定义方式：在函数体的外面定义的变量，称为普通全局变量

* 作用范围：==在当前的文件中，或者其他文件中都可以去使用(加关键字extern)，在其他文件中可以找到==

* 生命周期：整个程序结束后 释放

* 注意事项：==普通全局变量未初始化，结果为0；局部变量 未初始化 值是随机的 vs下不可以访问==

==在函数外定义，可被本文件及其它文件中的函数所共用，若其它文件中的函数调用此变量，须用extern声明。==

```c
int g_a = 10;//g---global
int g_c;

void test02()
{
	printf("g_a=%d\n", g_a);
}
```

### 8.1.3 静态局部变量

* 定义形式：在{}里定义，用static关键字修饰后，称为静态局部变量
* 作用范围：离最近的{}里面可以使用
* 生命周期：==整个程序结束后释放==
* 注意事项：==静态局部变量未初始化结果为0 只能初始化一次==

```c
int* func()
{
	static int s_b = 2000;

	return &s_b;
}

void func2()
{
	static int s_d = 3000;//只初始化了一次
	s_d++;
	printf("s_d=%d\n", s_d);
}

void test01()
{
	static int s_a = 1000;
	printf("s_a=%d\n", s_a);

	int* p = func();//生命周期：整个程序结束后释放
	printf("*p=%d\n", *p);

	static int s_c;
	printf("s_c=%d\n", s_c);

	//s_d只初始化了一次，所以以下的代码相当于累加
	func2();//3001
	func2();//3002
	func2();//3003
	func2();//3004
}

int main()
{
	test01();
    
	//printf("s_a=%d\n", s_a);//不能使用，是局部的
	system("pause");
	return EXIT_SUCCESS;
}
```

### 8.1.4 静态全局变量

* 定义形式：在函数体外部定义，用static关键字修饰后，称为静态全局变量
* 作用范围：==仅在当前文件内可以使用，超出这个文件用了extern也会报错==
* 生命周期：整个周期结束后释放
* 注意事项：==静态全局变量 未初始化 结果为0，只能初始化一次==

```c
static int g_s_a = 1000;
static int g_s_c;

void test02()
{
	printf("g_s_a=%d\n", g_s_a);

	printf("g_s_c=%d\n", g_s_c);
}
```

### 8.1.5 extern 全局变量声明

```c
	extern int a;//声明一个变量，这个变量在别的文件中已经定义了，这里只是声明，而不是定义。
```

### 8.1.6 全局函数和静态函数

​	==在C语言中函数默认都是全局的，使用关键字static可以将函数声明为静态，==函数定义为static就意味着这个函数只能在定义这个函数的

文件中使用，在其他文件中不能调用，即使在其他文件中声明这个函数都没用。

![img](file:///C:\Users\wenca\AppData\Local\Temp\ksohtml\wps5119.tmp.jpg)

## 8.2 内存四区

C代码经过**==预处理、编译、汇编、链接==**4步后生成一个可执行程序。

在 Linux 下，程序是一个普通的可执行文件，以下列出一个二进制可执行文件的基本情况：

![img](file:///C:\Users\wenca\AppData\Local\Temp\ksohtml\wps942B.tmp.jpg)

​	在没有运行程序前，也就是说程序没有加载到内存前，可执行程序内部已经分好3段信息，分别为代码区（text）、数据区（data）和

未初始化数据区（bss）3 个部分（有些人直接把data和bss合起来叫做静态区或全局区）。

​	==程序在加载到内存前，代码区和全局区(data和bss)的大小就是固定的，程序运行期间不能改变。运行可执行程序，系统把程序加载==

==到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。==

​	==**程序运行前**：分为代码区和全局区==

​	==**程序运行后**：分为代码区、全局区、栈区、堆区==

![img](file:///C:\Users\wenca\AppData\Local\Temp\ksohtml\wps3429.tmp.jpg)

### 8.2.1 运行前：代码区

​	特点：

**==（1）共享==**

**==（2）只读==**

### 8.2.2 运行前：全局区

​	包括两部分：

#### （1）全局初始化数据区/静态数据区（data段）

​	该区包含了在程序中明确**被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常**

**量）。**

#### （2）未初始化数据区（又叫bss区）

​	**==存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。==**

### 8.2.3 运行后：代码区

​	加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。

### 8.2.4 运行后：全局区

​	包括两部分：

#### （1）全局初始化数据区/静态数据区（data段）

​	加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过

程。

#### （2）未初始化数据区（又叫bss区）

​	加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期

为整个程序运行过程。

### 8.2.5 运行后：栈区

​	栈是一种**==先进后出==**的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释

放，因此，局部变量的生存周期为申请到释放该段栈空间。

### 8.2.6 运行后：堆区

​	堆是一个大容器，**==它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。==**堆在内存中位于BSS区和栈区之间。==**一**==

==**般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。**==

![2.76 内存四区](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.76 内存四区.png)

## 8.3 内存操作函数

### （1）memset 函数：内存设置

​	**==主要用途：清空内存==**

```c
#include <string.h>
void *memset(void *s, int c, size_t n);      memory set
功能：将s的内存区域的前n个字节以参数c填入
参数：
	s：需要操作内存s的首地址
	c：填充的字符，c虽然参数为int，但必须是unsigned char , 范围为0~255
	n：指定需要设置的大小
返回值：s的首地址
```

```c
void test01()
{
	char buf[32] = "hello world";
	printf("buf=%s\n", buf);

	//memset(buf, 'a', 32);//将buf的值全部用a替换，\0也会替换，所以输出会有乱码，一般不这样用
	//printf("buf=%s\n", buf);

	//主要用途：给内存清空
	memset(buf, 0, 32);
	printf("buf=%s\n", buf);//不输出
}
```

### （2）memcpy 函数：内存拷贝

​	==**主要用途：直接给数组进行赋值**==

```c
#include <string.h>
void *memcpy(void *dest, const void *src, size_t n);        memory copy
功能：拷贝src所指的内存内容的前n个字节到dest所值的内存地址上。
参数：
	dest：目的内存首地址
	src：源内存首地址，注意：dest和src所指的内存空间不可重叠
	n：需要拷贝的字节数
返回值：dest的首地址
```

==**strcpy 与 memcpy 的区别：**==

* ==**strcpy 是字符串拷贝，遇到 ' \0 ' 就结束拷贝**==
* ==**memcpy 是内存拷贝，把整个字符串都拷贝进去，遇到 ' \0 ' 也会继续拷贝**==

```c
void pintfArrar(char* arr, int len)
{
	for (int i = 0; i < len; i++)
	{
		printf("%c", arr[i]);
	}
	printf("###\n");
}

void test02()
{
	//strcpy与memcpy的区别
	//strcpy 字符串拷贝
	char dst[64] = { 0 };
	char src[64] = "hello\0world";
	strcpy(dst, src);//字符串拷贝，遇到\0就结束拷贝
	pintfArrar(dst, sizeof(dst));

	//memcpy  内存拷贝，把整个内存都拷贝了，不会
	memset(dst, 0, sizeof(dst));//清空dst
	memcpy(dst, src, sizeof(dst));//内存拷贝，把整个字符串都拷贝进去，遇到\0也会继续拷贝
	pintfArrar(dst, sizeof(dst));

	//主要用途：给数组进行赋值
	int arr[5] = { 1,2,3,4,5 };
	int arr2[5];

	//arr2=arr;//不能这样操作，数组名是首地址
	memcpy(arr2, arr, sizeof(arr));
	for(int i = 0; i < 5; i++)
	{
		printf("%d\n", arr2[i]);
	}
}
```

### （3）memmove 函数：内存移动

​	memmove() 功能用法和 memcpy() 一样，区别在于：==dest 和 src 所指的内存空间重叠时，memmove() 仍然能处理==，不过执行效率比

memcpy() 低些。

```c
void test03()
{
	int arr[5] = { 10,20,30,40,50 };

	//通过内存拷贝 实现操作
	// 顺序为：40->50  30->40  20->30 == 10 20 20 30 40
	//memcpy(arr + 2, arr + 1, 3 * sizeof(int));//不推荐用，有可能和预期效果不符合
	
	//顺序为：20 30 40当作一个整体盖在后面这一块数据 -> 30 40 50 == 10 20 20 30 40
	memmove(arr + 2, arr + 1, 3 * sizeof(int));//先复制一份，再完全拷贝过去，推荐用，效率比上面低，但是比较安全

	for (int i = 0; i < 5; i++)
	{
		printf("%d\n", arr[i]);
	}
}
```

### （3）memcmp 函数：内存比较

```c
#include <string.h>
int memcmp(const void *s1, const void *s2, size_t n);      memory compare
功能：比较s1和s2所指向内存区域的前n个字节
参数：
	s1：内存首地址1
	s2：内存首地址2
	n：需比较的前n个字节
返回值：
	相等：=0
	大于：>0
	小于：<0
```

==**strcmp 和 memcmp 函数的区别：**==

* ==**用strcmp比较时，遇到' \0 '结束比较。**==
* ==**用memcmp比较时，对整个字符串进行比较，包括' \0 '。**==

```c
void test04()
{
	char str1[32] = "hello\0world";
	char str2[32] = "hello\0aaa";

	//对于此例，用strcmp比较时，是相等的，因为遇到\0结束，\0前面的字符是一样的
	if (strcmp(str1, str2) == 0)//对比时，遇到\0就结束
	{
		printf("strcmp 对比结果：str1==str2\n");
	}
	else
	{
		printf("strcmp 对比结果：str1!=str2\n");
	}

	//对于此例，用memcmp比较时，不相等，他是对整个字符串进行比较，包括\0
	if (memcmp(str1, str2, sizeof(str1)) == 0)
	{
		printf("memcmp 对比结果：str1==str2\n");
	}
	else
	{
		printf("memcmp 对比结果：str1!=str2\n");
	}
}
```

## 8.4 堆区内存分配和释放：malloc 函数和 free 函数

### （1）malloc 函数：在堆区分配内存

* malloc函数在堆区申请成功内存后，会把该内存的首地址返回

* ==申请的空间是连续的空间，里面的内容是随机的，一般使用memset初始化==

* ==malloc函数返回一个void*万能指针，不需要强制类型转换即可给其他指针赋值==
* ![2.78 malloc的基本使用](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.78 malloc的基本使用.png)

```c
#include <stdlib.h>
void *malloc(size_t size);
功能：在内存的动态存储区(堆区)中分配一块长度为size字节的连续区域，用来存放类型说明符指定的类型。分配的内存空间内容不确定，一般使用memset初始化。
参数：
	size：需要分配内存大小(单位：字节)
返回值：
成功：分配空间的起始地址
失败：NULL
```

​	**分配的内存空间内容不确定，一般使用memset初始化。**

### （2）free 函数：释放堆区内存

​	==对同一内存空间多次释放会出错。==

```c
#include <stdlib.h>
void free(void *ptr);
功能：释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址。对同一内存空间多次释放会出错。
参数：
ptr：需要释放空间的首地址，被释放区应是由malloc函数所分配的区域。
返回值：无
```

```c
void test01()
{
	int* p = NULL;
	p = malloc(sizeof(int));//malloc函数返回一个void*万能指针，不需要强制类型转换即可给其他指针赋值
	
	if (p == NULL)
	{
		printf("申请失败\n");
		return;//退出函数
	}

	//申请成功
	//清空内存
	memset(p, 0, 4);//未清空前，里面的内容是随机的
	//printf("*p=%d\n", *p);//0

	*p = 1000;
	printf("*p=%d\n", *p);

	//释放内存
	free(p);
}
```

### （3）堆区案例：利用malloc实现简易版动态数组

```c
void setArray(int* arr, int len)
{
	printf("请给%d个元素进行赋值：\n", len);
	for (int i = 0; i < len; i++)
	{
		scanf("%d", &arr[i]);//要用地址，切记
		//scanf("%d", (arr + i));//同样的意思
	}
}

void printArray(int* arr, int len)
{
	for (int i = 0; i < len; i++)
	{
		printf("%d ", arr[i]);
	}
}

void test02()
{
	int num = 0;
	printf("请输入数组的元素个数：\n");
	scanf("%d", &num);

	//该数组放在堆区
	int* arr = malloc(sizeof(int) * num);//动态数组
	//int arr[10];//静态数组

	if (arr == NULL)
	{
		printf("申请失败\n");
		return;//退出函数
	}

	//清空内存
	memset(arr, 0, sizeof(int) * num);

	//设置元素
	setArray(arr, num);

	//输出数组
	printArray(arr, num);

	//释放数组
	free(arr);
}
```

## 8.5 内存操作注意事项

### （1）不要返回局部变量的地址

```c
int* func()
{
	int num = 10;//局部变量，在栈区分配空间，使用完这个函数之后自动释放
	return &num;
}

void test01()
{
	int* p = func();
	printf("*p=%d\n", *p);//10  编译器会做一层保护，保留这个数据，防止误操作
	printf("*p=%d\n", *p);//随机

	//总结：结果不重要，因为内存已经被释放，使用这块内存属于非法操作
}
```

### （2）可以返回静态变量的地址

​	因为静态变量在整个程序执行完之后才会被释放

```c
int* func2()
{
	static int num = 10;//静态变量，整个程序执行完之后才会被释放
	return &num;
}

void test02()
{
	int* p = func2();
	printf("*p=%d\n", *p);//10
	printf("*p=%d\n", *p);//10
	printf("*p=%d\n", *p);//10
	printf("*p=%d\n", *p);//10
}
```

### （3）不要操作已经释放的堆区空间

```c
void test03()
{
	//p是分配在栈区的，但是其指向的内容位于堆区
	int* p = malloc(sizeof(int));//p指向堆区
	printf("p=%d\n", p);
	*p = 1000;

	free(p);//相当于把p和堆区的这种关系给破坏掉了，所以后面不能再来操作这块内存了
	printf("p=%d\n", p);

	//*p = 1000;//错误，因为上面已经把堆区内存释放了，不可以再操作这块内存
}
```

### （4）不要释放野指针

```c
void test04()
{
	int* p = malloc(sizeof(int));
	//free(p);//相当于把p和堆区的这种关系给破坏掉了，所以后面不能再来操作这块内存了
	//free(p);//此时的p属于野指针，野指针不可以释放的，不允许重复释放

	//以上的代码写成下面形式，防止你重复写这段代码，下面的代码连续写两次也不会报错
	if (p != NULL)
	{
		free(p);
		p = NULL;
	}

	if (p != NULL)
	{
		free(p);
		p = NULL;
	}

	free(p);//经过以上操作后，也不会报错，p是一个空指针，是可以free
}
```

### （5）同级指针修饰内存失败

![2.79 内存操作注意事项_同级指针修饰内存失败](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.79 内存操作注意事项_同级指针修饰内存失败.png)

```c
void allocateSpace(int* pp)
{
	pp = alloc(sizeof(int));

	//这里打印成功了
	*pp = 1000;
	printf("*p=%d\n", *pp);
}

void test05()
{
	int* p = NULL;

	//值传递，形参不能改变实参
	allocateSpace(p);//实参p是一个指针，形参也是一个指针，相当于值传递

	//下面打印不成功，p指向的位置没有变，还是NULL  //我截图了，很好理解
	//*p = 1000;//相当于p的指向还是NULL，不能对其进行取解引用

	//printf("*p=%d\n", *p);
}
```

#### 1）解决办法一：利用函数的返回值

```c
int* allocateSpace2()
{
	int* pp = malloc(sizeof(int));
	return pp;
}

void test06()
{
	int* p = NULL;
	p = allocateSpace2();//把地址传过来了

	//此时p指向的位置发生了变化，指向了堆区的内存
	*p = 1000;//给堆区的内存赋值
	printf("*p=%d\n", *p);
	if (p != NULL)
	{
		free(p);
		p = NULL;
	}
}
```

#### 2）解决办法二：利用高级指针修饰低级指针

![2.79 内存操作注意事项_高级指针修饰低级指针](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.79 内存操作注意事项_高级指针修饰低级指针.png)

```c
void allocateSpace3(int** pp)//地址传递，形参可以改变实参
{
	*pp = malloc(sizeof(int));
}

//把堆区的内存释放，但是这会使原函数中的p指针变成野指针，所以后面还需再添加一条语句对p指向NULL
//void freeSpace1(int* pp)//对pp指针进行置空，不会使实参p的指针进行置空，也就是说p变成了一个野指针，需要在原函数中添加一个p=NULL进行释放
//{
//	if (pp != NULL)
//	{
//		free(pp);
//		pp = NULL;
//	}
//}

void freeSpace2(int** pp)//地址传递，形参改变了实参
{
	if (*pp != NULL)
	{
		free(*pp);//实际上就是释放了p
		*pp = NULL;//就是让p等于NULL
	}
}

void test07()
{
	int* p = NULL;

	//地址传递，形参可以改变实参
	allocateSpace3(&p);//地址传递

	* p = 2000;
	printf("*p=%d\n", *p);

	//因为指针p指向的那块内存在freeSpace函数中被释放了，所以这时p变成了一个野指针
	//freeSpace1(p);//传p进行释放，pp释放并不会影响p的释放，所以多此一举，p还是没有释放，要在下面加一个p=NULL对p进行释放
	//p = NULL;//指针p还是一个野指针，需要对指针p进行释放

	//if (p == NULL)
	//{
	//	printf("空指针\n");
	//}
	//else
	//{
	//	printf("野指针\n");
	//}

	freeSpace2(&p);//传p的地址进行释放
	if (p == NULL)
	{
		printf("空指针\n");
	}
	else
	{
		printf("野指针\n");
	}
}
```

## 8.6 堆区的的应用案例：动态数组

在myArray.h头文件中：

```c
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

//给数组分配内存
void allocateSpace(int** arr, int len);

//给元素赋值
void setArray(int* arr, int len);

//遍历数组
void printArray(int* arr, int len);

//给数组排序
void sortArray(int* arr, int len, int flag);

//获取最大值
int getMax(int* arr, int len);

//获取最小值
int getMin(int* arr, int len);

//获取平均数
int getAvg(int* arr, int len);

//获取总和
int getSum(int* arr, int len);

//释放数组
void freeArray(int** arr);
```

在myArray.c文件中：

```c
#include"myArray.h"

//给数组分配内存
void allocateSpace(int** arr, int len)
{
	*arr = malloc(sizeof(int) * len);

	if (*arr == NULL)
	{
		printf("申请失败\n");
		return;//退出函数
	}

	//清空内存
	memset(*arr, 0, sizeof(int) * len);
}

//给元素赋值
void setArray(int* arr, int len)
{
	printf("请给%d个元素赋值：\n", len);

	for (int i = 0; i < len; i++)
	{
		scanf("%d", &arr[i]);
	}
}

//遍历数组
void printArray(int* arr, int len)
{
	for (int i = 0; i < len; i++)
	{
		printf("%d ", arr[i]);
	}
}

//给数组排序  flag=0为升序  flag=1为降序
void sortArray(int* arr, int len, int flag)
{
	for (int i = 0; i < len - 1; i++)
	{
		for (int j = 0; j < len - i - 1; j++)
		{
			//假设升序
			if (flag == 0)//升序
			{
				if (arr[j] > arr[j + 1])
				{
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}
			else//降序
			{
				if (arr[j] < arr[j + 1])
				{
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}
		}
	}
}

//获取最大值
int getMax(int* arr, int len)
{
	int max = 0;
	for (int i = 0; i < len; i++)
	{
		if (arr[i] > arr[max])
		{
			max = i;
		}
	}
	return arr[max];
}

//获取最小值
int getMin(int* arr, int len)
{
	int min = 0;
	for (int i = 0; i < len; i++)
	{
		if (arr[i] < arr[min])
		{
			min = i;
		}
	}
	return arr[min];
}

//获取总和
int getSum(int* arr, int len)
{
	int sum = 0;
	for (int i = 0; i < len; i++)
	{
		sum += arr[i];
	}
	return sum;
}

//获取平均数
int getAvg(int* arr, int len)
{
	return getSum(arr, len) / len;
}

//释放数组
void freeArray(int** arr)
{
	if (*arr != NULL)
	{
		free(*arr);
		*arr = NULL;
	}
}
```

在main.c文件中：

```c
int main()
{
	int num = 0;
	printf("请输入数组元素个数：\n");
	scanf("%d", &num);

	int* arr = NULL;
	allocateSpace(&arr, num);

	//设置元素
	setArray(arr, num);

	//遍历数组
	printf("遍历的结果为：\n");
	printArray(arr, num);
	printf("\n");

	//排序结果  升序0
	sortArray(arr, num, 0);
	printf("升序后遍历的结果为：\n");
	printArray(arr, num);
	printf("\n");

	//排序结果  降序1
	sortArray(arr, num, 1);
	printf("降序后遍历的结果为：\n");
	printArray(arr, num);
	printf("\n");

	//剩余功能测试
	printf("总和：%d\t 平均值：%d\t 最大值：%d\t 最小值：%d\n",
		getSum(arr, num),
		getAvg(arr, num),
		getMax(arr, num),
		getMin(arr, num)
		);

	//释放数组
	freeArray(&arr);

	system("pause");
	return EXIT_SUCCESS;
}
```

# 9 复合类型（自定义类型）

## 9.1 结构体 struct

### 9.1.1 结构体变量的定义和初始化

语法：struct + 类型名称 { }+';'

只是一个类型的设计，并没有真正的一个变量存在，==这个类型只是一个磨具，没有空间，可以计算大小，但是其实上没有占用空间==

​	定义结构体变量的方式：

![img](file:///C:\Users\wenca\AppData\Local\Temp\ksohtml\wps26E7.tmp.jpg)

* （1）先声明结构体类型再定义变量名

```c
struct Student
{
	int id;//学号
	char name[64];//姓名
	double score;//分数
};

void test01()
{
	//创建结构体变量
	struct Student s1 = { 1,"张三",99.9 };
}
```

* （2）在声明类型的同时定义变量

```c
//设计结构体时候，同时创建出一个结构体变量
struct Student2
{
	int id;//学号
	char name[64];//姓名
	double score;//分数
}stu;//stu = { 1,"张三",99.9 };  //stu是一个结构体变量，也可以直接在后面赋值
```

* （3）直接定义结构体类型变量（无类型名）

```c
struct
{
	int id;//学号
	char name[64];//姓名
	double score;//分数
}stu;
```

​	结构体类型和结构体变量关系：

* **结构体类型：**指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，**==系统对之也不分配实际内存单元==**。
* **结构体变量：**==**系统根据结构体类型（内部成员状况）为之分配空间**==。

### 9.1.2 结构体成员赋值（三种方式）

#### （1）逐个成员赋值

​	==当结构体变量属性中有字符型数据时，不能直接用 ' = ' 进行赋值，要用字符串处理函数strcpy() 对其进行赋值。==

```c
void test03()
{
    struct Student s1;
	struct Student s2 = { 1,"张三",99.9 };	

	//方法1  逐个成员赋值
	s1.id = s2.id;
	//s1.name = s2.name;
	strcpy(s1.name, s2.name);//因为name是字符型数据，要用字符串处理函数strcpy来进行赋值
	s1.score = s2.score;

	printf("学号：%d\n", s1.id);
	printf("姓名：%s\n", s1.name);
	printf("分数：%lf\n", s1.score);
}
```

#### （2）整体赋值（相同数据类型的结构体变量）

```c
void test04()
{
    struct Student s1;
	struct Student s2 = { 1,"张三",99.9 };
    
    //方法2  整体赋值（相同数据类型的结构体变量之间）
	s1 = s2;
    
    printf("s1的信息-学号：%d 姓名：%s 得分：%f\n", s1.id, s1.name, s1.score);
	printf("s2的信息-学号：%d 姓名：%s 得分：%f\n", s2.id, s2.name, s2.score);
}
```

#### （3）利用内存拷贝函数 memcpy

```c
void test05()
{
    struct Student s1;
	struct Student s2 = { 1,"张三",99.9 };
    
	memcpy(&s1, &s2, sizeof(struct Student));//内存拷贝函数memcpy
    	
    printf("s1的信息-学号：%d 姓名：%s 得分：%f\n", s1.id, s1.name, s1.score);
	printf("s2的信息-学号：%d 姓名：%s 得分：%f\n", s2.id, s2.name, s2.score);
}
```

### 9.1.3 结构体变量交换（两种方式）

#### （1）逐个属性进行交换

```c
void test06()
{
    //交换学号
	int idTemp = s1.id;
	s1.id = s2.id;
	s2.id = idTemp;

	//交换姓名
	char nameTemp[64];
	strcpy(nameTemp, s1.name);//处理字符型数据用字符串处理函数
	strcpy(s1.name, s2.name);
	strcpy(s2.name, nameTemp);

	//交换分数
	int scoreTemp = s1.score;
	s1.score = s2.score;
	s2.score = scoreTemp;
    
    printf("s1的信息-学号：%d 姓名：%s 得分：%f\n", s1.id, s1.name, s1.score);
	printf("s2的信息-学号：%d 姓名：%s 得分：%f\n", s2.id, s2.name, s2.score);
}
```

#### （2）变量整体进行交换

```c
void test07()
{
    struct Student temp;
	temp = s1;
	s1 = s2;
	s2 = temp;

	printf("s1的信息-学号：%d 姓名：%s 得分：%f\n", s1.id, s1.name, s1.score);
	printf("s2的信息-学号：%d 姓名：%s 得分：%f\n", s2.id, s2.name, s2.score);
}
```

### 9.1.4 结构体数组初始化（两种方式）

#### （1）结构体数组直接初始化

```c
void test05()
{
	struct Student arr[5] = {
		{1,"张三",100},
		{2,"李四",90},
		{3,"王五",80},
		{4,"张飞",70},
		{5,"吕布",60}//最后一个成员的后面 可写可不写','
	};

	//遍历数组
	int len = sizeof(arr) / sizeof(struct Student);
	for (int i = 0; i < len; i++)
	{
		printf("学号：%d 姓名：%s 得分：%f\n", arr[i].id, arr[i].name, arr[i].score);
	}
}
```

#### （2）结构体数组从键盘获取信息

```c
void test06()
{
	struct Student arr[2];
	memset(arr, 0, sizeof(arr));//清空操作

	int len = sizeof(arr) / sizeof(arr[0]);
	printf("请给%d个学生进行赋值：\n", len);
	for (int i = 0; i < len; i++)
	{
		scanf("%d %s %lf", &arr[i].id, arr[i].name, &arr[i].score);
	}

	for (int i = 0; i < len; i++)
	{
		printf("学号：%d 姓名：%s 得分：%f\n", arr[i].id, arr[i].name, arr[i].score);
	}
}
```

### 9.1.5 结构体嵌套结构体

​	==要访问一个结构体中的另一个结构体变量要用**两个 ' . ' 符号**。==

```c
struct Stu
{
	int id;//学号
	int age;//姓名
};

struct Tea
{
	int id;//职工号
	struct Stu st;//学生
};

void test07()
{
	struct Tea t1 = { 100,{1,18} };
	struct Tea t2 = { 101,2,19 };

	printf("t1老师的职工号：%d 所带的学生学号：%d 学生年龄：%d\n", t1.id, t1.st.id, t1.st.age);
	printf("t2老师的职工号：%d 所带的学生学号：%d 学生年龄：%d\n", t2.id, t2.st.id, t2.st.age);
}
```

### 9.1.6 结构体和指针

#### 9.1.6.1 访问结构体变量属性（四种方式）

```c
void test01()
{
	struct Student s = { 1,"Tom",65.5 };
	struct Student* p = &s;

	//1、指针要利用->访问里面的成员
	printf("id=%d name=%s score=%lf\n", p->id, p->name, p->score);

	//2、而结构体变量用.即可访问里面的成员
	printf("id=%d name=%s score=%lf\n", s.id, s.name, s.score);

	//3、将指针解引用出来再访问里面的成员
	printf("id=%d name=%s score=%lf\n", (*p).id, (*p).name, (*p).score);

	//4、也可以将s取地址之后再利用->访问里面的成员，和第一种方法指针访问本质上一样
	printf("id=%d name=%s score=%lf\n", (&s)->id, (&s)->name, (&s)->score);
}
```

#### 9.1.6.2 通过指针来获取键盘的输入

```c
void test02()
{
	struct Student s;
	struct Student* p = &s;

	scanf("%d %s %lf", &p->id, p->name, &p->score);
	printf("id=%d name=%s score=%1f\n", p->id, p->name, p->score);
}
```

#### 9.1.6.3 结构体创建在堆区

```c
void test03()
{
	struct Student* p = malloc(sizeof(struct Student));

	if (p == NULL)//判断是否开辟成功，不成功就退出
	{
		return;//退出函数
	}

	scanf("%d %s %lf", &p->id, p->name, &p->score);
	printf("id=%d name=%s score=%1f\n", p->id, p->name, p->score);

	//释放堆区数据
	if (p != NULL)
	{
		free(p);
		p = NULL;
	}
}
```

#### 9.1.6.4 结构体数组创建在堆区

```c
void test04()
{
	printf("请输入元素的个数：\n");
	int n = 0;
	scanf("%d", &n);
	struct Student* arr = malloc(sizeof(struct Student) * n);

	//清空内存
	memset(arr, 0, sizeof(struct Student) * n);

	for (int i = 0; i < n; i++)
	{
		printf("请给第%d个学生赋值：\n", i + 1);

		//赋值方法1
		scanf("%d %s %lf", &arr[i].id, arr[i].name, &arr[i].score);
		
		//赋值方法2
		//scanf("%d %s %lf", &(arr + i)->id, (arr + i)->name, &(arr + i)->score);
		
		//赋值方法3
		//scanf("%d %s %lf", &(*(arr + i)).id, (*(arr + i)).name, &(*(arr + i)).score);
	}

	for (int i = 0; i < n; i++)
	{
		printf("id=%d name=%s score=%1f\n", arr[i].id, arr[i].name, arr[i].score);
	}

	//释放数组
	if (arr != NULL)
	{
		free(arr);
		arr = NULL;
	}
}
```

#### 9.1.6.5 const 修饰结构体指针

```c
struct Student
{
	int id;
	char* name;
	int age;
};

void test01()
{
	struct Student s1 = { 100,"Tom",18 };
	struct Student s2 = { 100,"Jerry",18 };

	//常量指针，指针指向的值不可以修改，指向可以修改
	const struct Student* p1 = &s1;//const离*比较近，所以指针指向的值不可以修改，即*p1不可以修改

	//p1->id = 200;//错误，指针指向的值不可以修改
	p1 = &s2;//正确，指针的指向可以修改

	//指针常量，指针的指向不可以修改，指向的值可以修改
	struct Student* const p2 = &s2;//
	p2->id = 200;//正确，指针指向的值可以修改
	//p2 = &s1;//错误，指针的指向不可以修改

	const struct Student* const p3 = &s1;
	//p3->id = 10;//错误，都不可以修改
	//p3 = &s2;//错误，都不可以修改
}
```

### 9.1.7 结构体作函数参数

#### （1）结构体普通变量作函数参数

```c
struct stu
{
	char name[50];
	int age;
};

//函数参数为结构体普通变量
void set_stu(struct stu tmp)  //值传递，形参不能修饰实参
{
	strcpy(tmp.name, "mike");//用字符串处理函数处理字符串数据
	tmp.age = 18;
	printf("tmp.name = %s, tmp.age = %d\n", tmp.name, tmp.age);
}

void test01
{
	struct stu s = { 0 };
	set_stu(s); //值传递
	printf("s.name = %s, s.age = %d\n", s.name, s.age);
}
```

#### （2）结构体指针变量作函数参数

```c
struct stu
{
	char name[50];
	int age;
};

//函数参数为结构体指针变量
void set_stu_pro(struct stu *tmp)   //地址传递，形参可以修饰实参
{
	strcpy(tmp->name, "mike");//用字符串处理函数处理字符串数据
	tmp->age = 18;
}

void test02()
{
	struct stu s = { 0 };
	set_stu_pro(&s); //地址传递
	printf("s.name = %s, s.age = %d\n", s.name, s.age);
}
```

#### （3）结构体数组名作函数参数

```c
//void setStudentArray(struct Student arr[2], int len)//写法1
//void setStudentArray(struct Student arr[], int len)//写法2
void setStudentArray(struct Student* arr, int len)//写法3
{
	for (int i = 0; i < len; i++)
	{
		printf("请给第%d个同学赋值：\n", i + 1);
		scanf("%d %s %lf", &arr[i].id, arr[i].name, &arr[i].score);
	}
}

void test06()
{
	struct Student arr[2];

	//清空内存
	memset(arr, 0, sizeof(arr[0]));

	int len = sizeof(arr) / sizeof(arr[0]);
	setStudentArray(arr, len);

	for (int i = 0; i < len; i++)
	{
		printf("id=%d name=%s score=%1f\n", arr[i].id, arr[i].name, arr[i].score);
	}
}
```

#### （4）const 修饰结构体指针形参变量

```c
struct stu
{
	char name[50];
	int age;
};

void fun1(struct stu * const p)
{
	//p = NULL; //err
	p->age = 10; //ok
}

//void fun2(struct stu const*  p)
void fun2(const struct stu *  p)
{
	p = NULL; //ok
	//p->age = 10; //err
}

void fun3(const struct stu * const p)
{
	//p = NULL; //err
	//p->age = 10; //err
}
```

### 9.1.8 结构体成员创建在堆区

#### （1）结构体创建在栈区，而结构体成员创建在堆区

![2.83 结构体成员创建在堆区](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.83 结构体成员创建在堆区.png)

```c
struct Student
{
	int id;//学号
	char* name;//姓名
	int age;//年龄
};

void test01()
{
	//不能修改Tom，要修改只能在堆区重新申请一块内存
	struct Student s = { 100,"Tom",18 };//"Tom"是字符串常量，放在常量区，不可以修改

	printf("id=%d name=%s age=%d\n", s.id, s.name, s.age);

	//s.name[0] = 'X';//错误，不能这样修改，"Tom"是放在常量区里面的，而name指向常量区，但是常量区里面的数据不可以修改
}

//我截图了，很好理解
void test02()
{
	struct Student s = { 100,NULL,18 };//结构体成员在堆区创建

	//通过在堆区创建一块内存去存储，去修改这个数据
	s.name = malloc(sizeof(char) * 64);
	strcpy(s.name, "Tom");
	printf("id=%d name=%s age=%d\n", s.id, s.name, s.age);

	//利用堆区的数据对其进行修改
	strcpy(s.name, "Jerry");
	printf("id=%d name=%s age=%d\n", s.id, s.name, s.age);

	if (s.name != NULL)
	{
		free(s.name);
		s.name = NULL;
	}
}
```

#### （2）结构体创建在堆区，结构体成员也创建在堆区

​	==先在堆区创建结构体，再在堆区创建结构体成员==

```c
void test03()
{
	struct Student* p = NULL;
	p = malloc(sizeof(struct Student));//结构体直接创建在堆区

	if (p == NULL)
	{
		return;
	}

	//清空内存
	memset(p, 0, sizeof(struct Student));

	//给结构体成员赋值
	p->id = 100;
	p->age = 20;

	//strcpy(p->name, "Tom");//不能直接赋值，因为此时name是一个野指针，必须先让他指向一块内存，我们才能给他进行赋值
	p->name = malloc(sizeof(char) * 64);//在堆区再开辟 一段内存
	strcpy(p->name, "Tom");

	printf("id=%d name=%s age=%d\n", p->id, p->name, p->age);

	//释放内存，先释放结构体成员的内存，再释放结构体的内存，与创建的顺序相反
	//先释放成员  姓名
	if (p->name != NULL)
	{
		free(p->name);
		p->name = NULL;
	}

	//再释放结构体本身
	if (p != NULL)
	{
		free(p);
		p = NULL;
	}
}
```

### 9.1.9 结构体嵌套一级指针案例

![2.85 结构体嵌套一级指针案例_超级难](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.85 结构体嵌套一级指针案例_超级难.png)

```c
struct Teacher
{
	char* name;//姓名，这里已经有一个结构体嵌套一级指针了
	int age;//年龄
};
void test01()
{
	//一、分配内存  从前往后分配
	//1、在堆区创建一个结构体数组，数组里面存放的是Teacher的地址
	struct Teacher** teaArray = malloc(sizeof(struct Teacher*) * 3);//把Teacher的指针放在堆区

	for (int i = 0; i < 3; i++)
	{
		//2、在堆区创建一段内存空间，将Teacher放到另一块堆区中
		//此时teaArray[i] == struct Teacher* p;每个元素都是这样的数据类型
		teaArray[i] = malloc(sizeof(struct Teacher));//把Teacher放在堆区

		//3、继续在堆区创建一段内存空间，将Teacher里面的name再放入到另一块堆区中
		teaArray[i]->name = malloc(sizeof(char) * 64);

		//给name赋值  需熟记strcpy和sprintf给字符串变量赋值
		//strcpy(teaArray[i]->name, "Teacher_1");//缺陷：只能对他们取同名，因此下面这个方法更好，可以取不一样的名字
		sprintf(teaArray[i]->name, "Teacher_%d", i + 1);//赋值为Teacher_1,Teacher_2,Teacher_3

		teaArray[i]->age = 30 + i;
	}

	//二、打印
	for (int i = 0; i < 3; i++)
	{
		printf("下面：%s 年龄：%d\n", teaArray[i]->name, teaArray[i]->age);
	}

	//三、释放  从后往前释放  写了几个malloc就释放几个堆区内存
	for (int i = 0; i < 3; i++)
	{
		//1、释放name
		if (teaArray[i]->name != NULL)
		{

			printf("%s被释放了\n", teaArray[i]->name);
			free(teaArray[i]->name);
			teaArray[i]->name = NULL;
		}

		//2、释放老师
		if (teaArray[i] != NULL)
		{
			printf("%s被释放了\n", teaArray[i]);
			free(teaArray[i]);
			teaArray[i] = NULL;
		}
	}
	//3、释放数组
	if (teaArray != NULL)
	{
		printf("%s被释放了\n", teaArray);
		free(teaArray);
		teaArray = NULL;
	}
}
```

## 9.2 联合体 union

![2.86 联合体的基本概念以及创建_概念](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.86 联合体的基本概念以及创建_概念.png)

* 联合union是一个能在同一个存储空间存储不同类型数据的类型；

* ==联合体所占的内存长度等于其最长成员的长度，也有叫做共用体；==

* 同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用；

* ==共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖；==

* ==共用体变量的地址和它的各成员的地址都是同一地址。==

### 9.2.1 联合体基本概念

（1）==所有数据共用一块内存空间，创建的时候取数据类型最大的空间作为自己的空间==

```c
union DATA
{
	int a;
	short b;
	char c;
};

void test01()
{
	printf("sizeof DATA=%d\n", sizeof(union DATA));

	//修改的空间都是共用的空间
	union DATA data;//创建一个联合体变量
	data.a = 10;//将这个空间的数据改为10
	data.b = 20;//将这个空间的数据改为20
	data.c = 30;//将这个空间的数据改为30

	//最终这个空间的数据为30，不管是a,b还是c都为30
	printf("%d\n", data.a + data.b + data.c);//90
}
```

（2）==低位字节数据 放入到 低地址端==

![2.86 联合体的基本概念以及创建_用法(难点)](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.86 联合体的基本概念以及创建_用法(难点).png)

```c
union DATA
{
	int a;
	short b;
	char c;
};

void test02()
{
	union DATA data;
	data.a = 0x01020304;//共用体变量的地址和它的各成员的地址都是同一地址

	//低位字节数据 放入到 低地址端
	printf("data.a=%#x\n", data.a);//0x01020304
	printf("data.b=%#x\n", data.b);//0x0304
	printf("data.c=%#x\n", data.c);//0x04
}
```

### 9.2.2 联合体案例

![2.86 联合体的基本概念以及创建_联合体案例(难点)](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.86 联合体的基本概念以及创建_联合体案例(难点).png)

```c
union DATA
{
	int a;
	short b;
	char c;
};

void test03()
{
	union DATA data;
	data.a = 0x01020304;
	data.b = 0x0102;
	data.c = 0x01;

	printf("%#x\n", data.a + data.b + data.c);//0x01020203
}
```

## 9.3 枚举 enum

​	枚举（enumerate）：将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。

​	枚举类型定义：

```c
enum  枚举名
{
	枚举值表
};
```

* 在枚举值表中应列出所有可用值，也称为枚举元素。

* ==枚举值是常量，不能在程序中用赋值语句再对它赋值。==

* ==举元素本身由系统定义了一个表示序号的数值从0开始顺序定义为0，1，2 …==

**有点类似于宏定义，编译器默认从0开始输出，对其进行赋值可以对其改变**

**利用的意义：批量修改代码**

```c
enum POKER
{
	//HONGTAO = 2, HEITAO = 7, MEIHUA, FANGPIAN //可以这样操作
	HONGTAO, HEITAO, MEIHUA, FANGPIAN
};

void test01()
{
	enum POKER poker;//定义一个枚举变量
	poker = HONGTAO;

	//打印出来的数是一个int型的数据
	printf("%d\n", poker);//0  利用枚举变量输出
	printf("%d\n", HONGTAO);//0  利用枚举名输出
	printf("%d\n", HEITAO);//1
	printf("%d\n", MEIHUA);//2
	printf("%d\n", FANGPIAN);//3

	//HEITAO = 4;//错误，他是一个常量，不能修改
}

//#define FALSE 0
//#define TRUE 1

enum BOOL//和上面的宏定义意义一样
{
	FALSE,TRUE  //FALSE表示0，TRUE表示1
};

void test02()
{
	enum BOOL flag;
	flag = FALSE;
	flag = TRUE;

	if (flag)
	{
		printf("flag为真\n");
	}
	else
	{
		printf("flag为假\n");
	}
}

//#define WIDTH 600
//#define HEIGHT 500

enum//这个枚举名字也可以不写，和上面的宏定义意义一样
{
	WIDTH = 600, WEIGHT = 500
};

void test03()
{
	//直接使用，枚举变量都不用创建
	printf("宽度为：%d\n", WIDTH);
	printf("高度为：%d\n", WEIGHT);
}
```

## 9.4 typedef 的使用

### （1）给数据类型取别名

==**语法：typedef 原名 别名**==

用途：给数据类型 起别名，只是名字变了，用法是一样的

```c
typedef int MYINT;

void test01()
{
	int num1 = 10;
	MYINT num2 = 20;

	printf("num1=%d\n", num1);
	printf("num2=%d\n", num2);
}
```

### （2）简化 struct 关键字（两种方式）

​	**1）先定义结构体，再给结构体类型取别名**

```c
struct itcastCPPStudent
{
	char name[64];
	int age;
};

typedef struct itcastCPPStudent student;//给数据类型起别名

void test02()
{
	struct itcastCPPStudent s1 = { "Tom",18 };
	student s2 = { "Jerry",12 };
}
```

​	**2）定义结构体的同时给结构体类型取别名**

```c
typedef struct itcastCPPStudent
{
	char name[64];
	int age;
}student;   //这时的student不是结构体变量了，而是一个结构体类型，是一个别名

void test02()
{
	struct itcastCPPStudent s1 = { "Tom",18 };
	student s2 = { "Jerry",12 };
}
```

### （3）区分数据类型

```c
void test03()
{
	typedef char* PCHAR;
	PCHAR p1, p2;//此时p1和p2都是char*的数据类型
	
	//char* p1, p2;//此时p1是char*数据类型，p2是char数据类型
	//char* p1, *p2;//此时p1，p2都是char*数据类型

	printf("sizeof p1=%d\n", sizeof(p1));//p1是char*数据类型
	printf("sizeof p2=%d\n", sizeof(p2));//p2是char数据类型
}
```

# 10 文件操作

![2.89 文件的基本概念](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.89 文件的基本概念.png)

## 10.1 文件的分类

​	==**文件分为：**==

​			==**1、磁盘文件**==

​			==**2、设备文件**==

### 10.1.1 磁盘文件

​	指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存。

1、计算机的存储在**==物理上==**是二进制的，所以物理上所有的磁盘文件本质上都是一样的：

* ==以字节为单位进行顺序存储。==

2、从用户或者操作系统使用的角度（**==逻辑上==**）把文件分为：

* ==**文本文件**：基于**字符编码**的文件==

* ==**二进制文件**：基于**值编码**的文件==

#### （1）文本文件

* 基于==**字符编码**==，常见编码有ASCII、UNICODE等

* 一般可以使用文本编辑器直接打开

* 数5678的以ASCII存储形式(ASCII码)为：00110101 00110110 00110111 00111000

#### （2）二进制文件

* 基于==**值编码**==，自己根据具体应用，指定某个值是什么意思

* 把内存中的数据按其在内存中的存储形式原样输出到磁盘上

* 数5678的存储形式(二进制码)为：00010110 00101110

### 10.1.2 设备文件

​	在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。

## 10.2 文件的打开和关闭

### 10.2.1 文件指针

​	FILE是系统使用typedef定义出来的有关文件信息的一种结构体类型，结构体中含有文件名、文件状态和文件当前位置等信息。

​	==声明FILE结构体类型的信息包含在头文件“stdio.h”中，一般设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变==

==量==。通过文件指针就可对它所指的文件进行各种操作。

```c
typedef struct
{
	short           level;	//缓冲区"满"或者"空"的程度 
	unsigned        flags;	//文件状态标志 
	char            fd;		//文件描述符
	unsigned char   hold;	//如无缓冲区不读取字符
	short           bsize;	//缓冲区的大小
	unsigned char   *buffer;//数据缓冲区的位置 
	unsigned        ar;	 //指针，当前的指向 
	unsigned        istemp;	//临时文件，指示器
	short           token;	//用于有效性的检查 
}FILE;
```

![img](file:///C:\Users\wenca\AppData\Local\Temp\ksohtml\wps4F8A.tmp.jpg)

![2.89 文件的基本概念](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.89 文件的基本概念.png)

C语言中有三个特殊的文件指针由系统默认打开，用户无需定义即可直接使用:

* ==**stdin： 标准输入**，默认为当前终端（键盘）==，我们使用的**scanf、getchar**函数默认从此终端获得数据。

* ==**stdout：标准输出**，默认为当前终端（屏幕）==，我们使用的**printf、puts**函数默认输出信息到此终端。

* ==**stderr：标准出错**，默认为当前终端（屏幕）==，我们使用的**perror**函数默认输出信息到此终端。

### 10.2.2 文件的打开

```c
#include <stdio.h>
FILE* fopen(const char * filename, const char * mode);
功能：打开文件
参数：
	filename：需要打开的文件名，根据需要加上路径
	mode：打开文件的模式设置
返回值：
	成功：文件指针
	失败：NULL
```

1、**第一个参数**的几种形式：

​	（1）==**相对路径：**==

​		1）**打开当前目录passdw文件**：源文件(源程序)所在目录

```c
	FILE *fp_passwd = NULL;

	FILE *fp_passwd = fopen("passwd.txt", "r");
```

​		2）**打开当前目录(test)下passwd.txt文件**：

```c
	FILE *fp_passwd = NULL;

	fp_passwd = fopen(". / test / passwd.txt", "r");
```

​		3）**打开当前目录上一级目录（相对当前目录）passwd.txt文件**：

```c
	FILE *fp_passwd = NULL;	

	fp_passwd = fopen(".. / passwd.txt", "r");
```

​	（2）**==绝对路径：==**

​		**打开C盘test目录下一个叫passwd.txt文件：**

```c
	FILE *fp_passwd = NULL;

	fp_passwd = fopen("c://test//passwd.txt","r");
```

2、**第二个参数**的几种形式：

| **打开模式** | **含义**                                                     |
| ------------ | ------------------------------------------------------------ |
| r或rb        | 以只读方式打开一个文本文件（不创建文件，若文件不存在则报错） |
| w或wb        | 以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) |
| a或ab        | 以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件   |
| r+或rb+      | 以可读、可写的方式打开文件(不创建新文件)                     |
| w+或wb+      | 以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) |
| a+或ab+      | 以添加方式打开文件，打开文件并在末尾更改文件，若文件不存在则创建文件 |

![2.90 fopen函数介绍_文本文件和二进制文件的本质区别](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.90 fopen函数介绍_文本文件和二进制文件的本质区别.png)

* b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的。
* ==Unix和Linux下所有的文本文件行都是\n结尾，而Windows所有的文本文件行都是\r\n结尾==。
* 在Windows平台下，**以“文本”方式打开文件，不加b**：

​		（1）当**读取文件**的时候，系统会**将所有的 "\r\n" 转换成 "\n"**。

​		（2）当**写入文件**的时候，系统会**将 "\n" 转换成 "\r\n" 写入** 。

​		（3）==**以"二进制"方式打开文件，则读\写都不会进行这样的转换**==。

* 在Unix/Linux平台下，“文本”与“二进制”模式没有区别，"\r\n" 作为两个字符原样输入输出

### 10.2.3 文件的关闭

​	关闭文件很有必要，因为**写文件时，是先把代码从磁盘运送到缓冲区中，再从缓冲区中同时取多个数据**，比如说1024个数据，他以

1024为单位运送进去，如果这时有1025个数据，这时剩余的这个数据在fclose()之后就会写入进去。

​	==**fclose()的作用是，把缓冲区中最后的数据写入进去。**==

任何文件在使用后应该关闭：

* 打开的文件会占用内存资源，如果总是打开不关闭，会消耗很多内存

* 一个进程同时打开的文件数是有限制的，超过最大同时打开文件数，再次调用fopen打开文件会失败

* 如果没有明确的调用fclose关闭打开的文件，那么程序在退出的时候，操作系统会统一关闭。

```c
#include <stdio.h>
int fclose(FILE * stream);
功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资源。
参数：
	stream：文件指针
返回值：
	成功：0
	失败：-1
```

```c
void test01()
{
	//写文件
	FILE* f_write = fopen("test1.txt", "w");

	//如果是写文件，磁盘已满，会返回空指针
	//如果是读文件，文件不存在，会返回空指针
	if (f_write == NULL)
	{
		printf("文件打开失败\n");
		return;
	}

	//写文件具体操作.....

	//关闭文件，
	//很有必要，因为写文件时，是先把代码从磁盘运送到缓冲区中
	//再从缓冲区中同时取多个数据，比如说1024个数据，他以1024为单位运送进去
	//如果这时有1025个数据，这时剩余的这个数据在fclose()之后就会写入进去
	//fclose()的作用是，把缓冲区中最后的数据写入进去
	fclose(f_write);

}
```

## 10.3 文件的读写方式

### 10.3.1 按照字符方式读写文件 fputc、fgetc

#### （1）字符方式写文件 fputc

```c
#include <stdio.h>
int fputc(int ch, FILE * stream);
功能：将ch转换为unsigned char后写入stream指定的文件中
参数：
	ch：需要写入文件的字符
	stream：文件指针
返回值：
	成功：成功写入文件的字符
	失败：返回-1
```

​	==一个一个字符往文件中写入：==

```c
char buf[] = "this is a test for fputc";
int i = 0;
int n = strlen(buf);
for (i = 0; i < n; i++)
{
	//往文件fp写入字符buf[i]
	int ch = fputc(buf[i], fp);
	printf("ch = %c\n", ch);
}
```

![2.91 fgetc和fputc函数_字符方式读文件和写文件_两文件的十六进制代码区别](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.91 fgetc和fputc函数_字符方式读文件和写文件_两文件的十六进制代码区别.png)

![2.91 fgetc和fputc函数_字符方式读文件和写文件_ASCII码表](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.91 fgetc和fputc函数_字符方式读文件和写文件_ASCII码表.png)

```c
void test01()
{
	//打开文件
	// 见2.90照片，我截图了，很好理解
	// 在vs打开文件时，打开方式选择 文件---二进制编辑器即可查看16进制代码，对照代码可以发现多了一个0D，转换成ASCII码之后是\r，就是多了一个\r
	FILE* f_write = fopen("test01.txt", "w");//文本文件，该文件13个字节  程序下\n，磁盘存\r\n
	//FILE* f_write = fopen("test02.txt", "wb");//二进制文件，该文件12个字节  程序下\n，磁盘存\n
	if (f_write == NULL)
	{
		printf("文件打开失败\n");
		return;
	}

	//如果想在文件中换行的话，必须在后面手动添加一个\n字符
	char buf[32] = "hello world\n";

	//开始写文件
	int i = 0;
	while (buf[i] != '\0')
	{
		fputc(buf[i], f_write);
		i++;
	}

	//关闭文件
	fclose(f_write);
}
```



#### （2）文件结尾 EOF 和 feof

​		1）在C语言中，EOF表示文件结束符(end of file)。==在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文==

==件，必须是**文本文件**==。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能

出现-1，因此可以用EOF作为文件结束标志。

```c
	#define EOF     (-1)
```

​		2）当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问

题，ANSI C提供一个feof函数，用来判断文件是否结束。==feof函数既可用以判断二进制文件又可用以判断文本文件。==

```c
#include <stdio.h>
int feof(FILE * stream);
功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。
参数：
	stream：文件指针
返回值：
	非0值：已经到文件结尾
	0：没有到文件结尾
```

* ==**feof 函数判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。**==
* ==**二进制文件只能用feof函数来判断文件尾，而文本文件可以用EOF和feof函数来判断文件尾。**==

#### （3）字符方式读文件 fgetc

```c
#include <stdio.h>
int fgetc(FILE * stream);
功能：从stream指定的文件中读取一个字符
参数：
	stream：文件指针
返回值：
	成功：返回读取到的字符
	失败：-1
```

```c
char ch;
#if 0
while ((ch = fgetc(fp)) != EOF)
{
	printf("%c", ch);
}
printf("\n");
#endif

while (!feof(fp)) //文件没有结束，则执行循环
{
	ch = fgetc(fp);
	printf("%c", ch);
}
printf("\n");
```

```c
void test02()
{
	//打开文件
	FILE* f_read = fopen("test01.txt", "r");

	//判断是否打开文件成功
	if (f_read == NULL)
	{
		printf("文件打开失败\n");
		return;
	}

	//读文件
	//文件尾的标志  EOF  end of file文件尾，如果读到EOF则代表读到了文件尾
	//EOF是一个字符
	char ch = 0;
	//如果读取的信息不是文件的尾部，就一直循环读取，并且放入到ch中
	while (ch = fgetc(f_read) != EOF)
	{
		printf("%c", ch);
	}
}
```

#### （4）字符方式读写文件案例：将用户输入写入文件中

```c
void test03()
{
	FILE* f_write = fopen("a.txt", "w");
	if (f_write == NULL)
	{
		printf("文件打开失败\n");
		return;
	}

	while (1)
	{
		char buf[128] = { 0 };
		fgets(buf, sizeof(buf), stdin);

		//先判断是否要退出循环
		if (strncmp(buf, ":quit", 5) == 0)//比较函数
		{
			break;//退出循环
		}

		//开始写文件
		//buf -> hello world\n\0
		int i = 0;
		while (buf[i] != '\0')
		{
			fputc(buf[i], f_write);
			i++;
		}
	}

	//关闭文件
	fclose(f_write);
}
```

### 10.3.2 按照行方式读写文件 fputs、fgets

#### （1）行方式写文件 fputs

```c
#include <stdio.h>
int fputs(const char * str, FILE * stream);
功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\0'  不写入文件。 
参数：
	str：字符串
	stream：文件指针
返回值：
	成功：0
	失败：-1
```

```c
void test04()
{
	FILE* f_write = fopen("test04.txt", "w");

	//判断文件是否打开成功
	if (f_write == NULL)
	{
		printf("文件打开失败\n");
		return;
	}

	//之所以是char*是因为返回字符串的地址
	char* buf[] = { "锄禾日当午\n","汗滴禾下土\n","谁知盘中餐\n","粒粒皆辛苦\n" };

	//开始写文件
	int len = sizeof(buf) / sizeof(char*);
	for (int i = 0; i < len; i++)
	{
		fputs(buf[i], f_write);
	}

	//关闭文件
	fclose(f_write);
}
```

#### （2）行方式读文件 fgets

```c
#include <stdio.h>
char * fgets(char * str, int size, FILE * stream);
功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\0' 作为字符串结束。
参数：
	str：字符串
	size：指定最大读取字符串的长度（size - 1）
	stream：文件指针
返回值：
	成功：成功读取的字符串
	读到文件尾或出错： NULL
```

​	从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了**size - 1**个字符为止，最

后会自动加上字符 '\0' 作为字符串结束。

```c
void test05()
{
	FILE* f_read = fopen("test04.txt", "r");
	if (f_read == NULL)
	{
		printf("文件打开失败\n");
		return;
	}
//自定义条件编译，666牛逼牛逼
#if 0  //如果为0则注释掉了，如果为1就重新激活有用了

	//开始读文件
	//一个一个字符读，读到EOF文件尾就结束
	//一行一行字符读，利用feof()函数
	//feof(FILE*)
	//非0：已经到文件尾
	//0：没有到文件尾
	char buf[1024] = { 0 };

	while (!feof(f_read))//如果没有读取到文件尾  一直按行读文件
	{
		char* ret = fgets(buf, sizeof(buf), f_read);
		
		//最后一行是空行，由于无东西，他记录了上一行的数据，所以输出一样的行
		//又由于把最后一行的结束符\n改成了\0，所以苦字也输出不出来
		
		//fgets()读到文件尾或者出错的地方会返回NULL
		//防止最后打印出一行一样的数据
		if (ret == NULL)
		{
			break;
		}
		
		//多打印了一个换行符
		//将\n改为\0  解决多一个换行符的问题
		buf[strlen(buf) - 1] = '\0';

		printf("%s\n", buf);
	}
#else  //else表示不执行上述代码而执行以下代码
	//优化上述代码
	char buf[1024] = { 0 };
	while (fgets(buf, sizeof(buf), f_read))
	{
		buf[strlen(buf) - 1] = '\0';
		printf("%s\n", buf);
	}
#endif
}
```

### 10.3.3 按照格式化方式读写文件 fprintf、fscanf

#### （1）格式化方式写文件 fprintf

```c
#include <stdio.h>
int fprintf(FILE * stream, const char * format, ...);
功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，指定出现字符串结束符 '\0'  为止。
参数：
	stream：已经打开的文件
	format：字符串格式，用法和printf()一样
返回值：
	成功：实际写入文件的字符个数
	失败：-1
```

​	==将结构体的成员一个一个拆出来写入到文件中，用记事本可以解析出来==

```c
struct Hero
{
	char name[64];//姓名
	int atk;//攻击力
	int def;//防御力
};

void test06()
{
	struct Hero heroArray[5] =
	{
		{"刘备",1000,1800},
		{"关羽",1200,1000},
		{"张飞",1500,1500},
		{"曹操",1300,1300},
		{"吕布",2000,2000}
	};

	FILE* f_write = fopen("hero.txt", "w");
	if (f_write == NULL)
	{
		printf("文件打开失败\n");
		return;
	}
	int len = sizeof(heroArray) / sizeof(struct Hero);
	for (int i = 0; i < len; i++)
	{
		//一个中文代表两个字符，后面还有一个换行符
		int len = fprintf(f_write, "[姓名]%s [攻击力]%d [防御力]%d\n", heroArray[i].name, heroArray[i].atk, heroArray->def);
		printf("len = %d\n", len);//成功写入的字符数
	}

	//关闭文件
	fclose(f_write);
}
```

#### （2）格式化方式读文件 fscanf

```c
#include <stdio.h>
int fscanf(FILE * stream, const char * format, ...);
功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。
参数：
	stream：已经打开的文件
	format：字符串格式，用法和scanf()一样
返回值：
	成功：参数数目，成功转换的值的个数
	失败： - 1
```

​	==注意参数要取地址==

```c
void test07()
{
	//打开文件
	FILE* f_read = fopen("hero.txt", "r");

	//判断文件是否打开成功
	if (f_read == NULL)
	{
		printf("文件打开失败\n");
		return;
	}

	//准备一个接受从文件中读出来的数据的数组
	struct Hero heroArray[5];

	//清空数组
	memset(heroArray, 0, sizeof(heroArray));

	//开始读文件
	int i = 0;
	while (!feof(f_read))//没有读取到文件尾，执行这个循环
	{
		fscanf(f_read, "[姓名]%s [攻击力]%d [防御力]%d\n", heroArray[i].name, &heroArray[i].atk, &heroArray[i].def);//注意取地址
		i++;
	}

	int len = sizeof(heroArray) / sizeof(struct Hero);
	for (int i = 0; i < len; i++)
	{
		printf("name = %s atk = %d def = %d\n", heroArray[i].name, heroArray[i].atk, heroArray[i].def);
	}

	//关闭文件
	fclose(f_read);
}
```



### 10.3.4 按照块方式读写文件 fwrite、fread

#### （1）块方式写文件 fwrite

```c
#include <stdio.h>
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
功能：以数据块的方式给文件写入内容
参数：
	ptr：准备写入文件数据的地址
	size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小
	nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb
	stream：已经打开的文件指针
返回值：
	成功：实际成功写入文件数据的块数目，此值和nmemb相等
	失败：0
```

​	==直接将整个结构体写入到文件中，用记事本解析不出来==

```c
void test08()
{
	FILE* f_write = fopen("test06.txt", "w");
	if (f_write == NULL)
	{
		printf("文件打开失败\n");
		return;
	}

	struct Hero heroArray[5] =
	{
		{"刘备",1000,1800},
		{"关羽",1200,1000},
		{"张飞",1500,1500},
		{"曹操",1300,1300},
		{"吕布",2000,2000}
	};
	int len = sizeof(heroArray) / sizeof(struct Hero);

	//for (int i = 0; i < len; i++)
	//{
	//	//参数1 数据的地址  参数2 块大小  参数3 块的数量  参数4 文件指针
	//	fwrite(&heroArray[i], sizeof(struct Hero), 1, f_write);
	//}

	//一次性写入，和上面意思是一样的，将5块数据一下子全部写入进去了，因为数组的地址是连续的
	fwrite(heroArray, sizeof(struct Hero), 5, f_write);

	//关闭文件
	fclose(f_write);
}
```

#### （2）块方式读文件 fread

```c
#include <stdio.h>
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
功能：以数据块的方式从文件中读取内容
参数：
	ptr：存放读取出来数据的内存空间
	size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小
	nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb
	stream：已经打开的文件指针
返回值：
	成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。
	失败：0
```

```c
void test09()
{
	FILE* f_read = fopen("test06.txt", "r");
	if (f_read == NULL)
	{
		printf("文件打开失败\n");
		return;
	}

	struct Hero heroArray[5];
	memset(heroArray, 0, sizeof(heroArray));
	int len = sizeof(heroArray) / sizeof(struct Hero);

	//for (int i = 0; i < len; i++)
	//{
	//	//参数1 数据的地址  参数2 块大小  参数3 块的数量  参数4 文件指针
	//	fread(&heroArray[i], sizeof(struct Hero), 1, f_read);
	//}

	//一次性读取，和上面意思是一样的，将5块数据一下子全部读进去了，因为数组的地址是连续的
	//fread(heroArray, sizeof(struct Hero), 5, f_read);

	//遍历
	for (int i = 0; i < len; i++)
	{
		printf("name = %s atk = %d def = %d\n", heroArray[i].name, heroArray[i].atk, heroArray[i].def);
	}
}
```

## 10.4 文件操作案例1：文件的四则运算

​	在calculator.h头文件中：

```c
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<time.h>

//出题
void setQuestion();

//解题
void answerQuestion();
```

​	在calculator.c源文件中

```c
#include"calculator.h"

//出题
void setQuestion()
{
	//设置随机数种子
	srand((unsigned int)time(NULL));

	//创建随机数的变量、运算符
	int num1 = 0;
	int num2 = 0;
	char ch = 0;
	char oper[] = { '+','-','*','/' };//[]里面的数字表示0~3

	FILE* f_write = fopen("test05.txt", "w");//'w'表示文件不存在时，创建一个新文件
	if (f_write == NULL)
	{
		printf("文件打开失败\n");
		return;
	}

	for (int i = 0; i < 50; i++)
	{
		//产生随机数1~100
		num1 = rand() % 100 + 1;
		num2 = rand() % 100 + 1;
		ch = oper[rand() % 4];//[]里面代表0~3的随机数

		//拼接字符串  1+1=    用字符串拼接函数sprintf()
		char msg[64] = { 0 };
		sprintf(msg, "%d %c %d = \n", num1, ch, num2);

		//printf("%s", msg);//测试代码

		//写到文件中
		fputs(msg, f_write);

	}

	//关闭文件
	fclose(f_write);
	printf("50道题目生成完毕\n");
}

//解题
void answerQuestion()
{
	//打开出题的那个文件
	FILE* fp1 = fopen("test05.txt", "r");

	//打开新创建的一个文件，就是解出来之后又存到另一个文件中去
	FILE* fp2 = fopen("answer.txt", "w");

	//判断两个文件是否打开成功
	//if (!fp1 || !fp2)
	if (fp1 == NULL || fp2 == NULL)//两个代码一个意思
	{
		printf("文件打开失败\n");
		return;
	}

	//读文件  按行读文件
	char buf[64] = { 0 };
	while (fgets(buf, sizeof(buf), fp1))//只要读取到内容进行循环解题操作
	{
		//printf("%s", buf);//测试代码，测试他读回来了
		//buf     1+2=   将1、2、=分别拆出来

		int num1 = 0;
		int num2 = 0;
		char ch = 0;

		//sscanf字符串拆分函数
		sscanf(buf, "%d %c %d", &num1, &ch, &num2);

		//测试代码
		//printf("num1 = %d\n", num1);
		//printf("num2 = %d\n", num2);
		//printf("ch = %c\n", ch);

		//创建计算结果的变量
		int ret = 0;
		switch (ch)
		{
		case '+':
			ret = num1 + num2;
			break;
		case '-':
			ret = num1 - num2;
			break;
		case '*':
			ret = num1 * num2;
			break;
		case '/':
			ret = num1 / num2;
			break;
		default:
			break;
		}

		//组装新的字符串信息
		char str[64] = { 0 };

		//拼接字符串  1+1=    用字符串拼接函数sprintf()
		sprintf(str, "%d %c %d = %d\n", num1, ch, num2, ret);

		//printf("ret = %s\n", str);//测试代码

		//按行写文件
		fputs(str, fp2);
	}

	fclose(fp1);
	fclose(fp2);
	printf("所有题目解答完毕\n");
}
```

## 10.5 文件操作案例2：文件版排序

​	需求：生成100个随机数进行排序，生成100个随机数，并将其写入到一个文件中。

```c
void test01()
{
	//随机数种子
	srand((size_t)time(NULL));

	//打开文件
	FILE* f_write = fopen("随机数.txt", "w");
	if (f_write == NULL)
	{
		printf("文件打开失败\n");
		return;
	}

	for (int i = 0; i < NUM; i++)
	{
		fprintf(f_write, "%d\n", rand() % 100 + 1);//1~100的随机数
	}

	//关闭文件
	fclose(f_write);
}

//冒泡排序
void bubbleSort(int arr[],int len)
{
	for (int i = 0; i < len; i++)
	{
		for (int j = 0; j < len - i - 1; j++)
		{
			//升序
			if (arr[j] > arr[j + 1])
			{
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
}

//将上面那个文件读取，再排序，再写入到另一个文件中
void test02()
{
	FILE* fp1 = fopen("随机数.txt", "r");
	FILE* fp2 = fopen("排序后.txt", "w");

	if (!fp1 || !fp2)
	{
		printf("文件打开失败\n");
		return;
	}

	//准备一个数组去存放这100个随机数
	int arr[NUM] = { 0 };

	for (int i = 0; i < NUM; i++)
	{
		fscanf(fp1, "%d\n", &arr[i]);
	}

	//给数组排序
	bubbleSort(arr, NUM);

	//将排序后的数组写入到fp2文件中
	for (int i = 0; i < NUM; i++)
	{
		fprintf(fp2, "%d\n", arr[i]);
	}

	//关闭文件
	fclose(fp1);
	fclose(fp2);
}
```

## 10.6 文件的随机读写

### 10.6.1 fseek 函数：移动文件光标的读写位置

```c
#include <stdio.h>
int fseek(FILE *stream, long offset, int whence);
功能：移动文件流（文件光标）的读写位置。
参数：
	stream：已经打开的文件指针
	offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。
	whence：其取值如下：
		SEEK_SET：从文件开头移动offset个字节
		SEEK_CUR：从当前位置移动offset个字节
		SEEK_END：从文件末尾移动offset个字节
返回值：
	成功：0
	失败：-1
```

```c
void test01()
{
	FILE* fp = fopen("test07.txt", "w+");
	if (fp == NULL)
	{
		printf("文件打开失败\n");
		return;
	}

	fputs("hello world", fp);
	//输出有错误：因为写入完成后，光标位于文件的末尾，所以再读取的话，后面没有东西可以读，会读取到乱码的情况
#if 0
	// 解决办法一：写入完成之后，立马关闭文件，再重新打开文件进行读取
	fclose(fp);//关闭文件
	fp = fopen("test07.txt","r");//重新打开文件，相当于光标回到了原始位置

#else
	// 解决办法二：利用函数将光标放回到原始位置
	// 也有以下几种方法：
	//fseek(fp, 0, SEEK_SET);//从文件起始位置移动

	//fseek(fp, -11, SEEK_END);//从文件结束位置移动

	//fseek(fp, 0, SEEK_END);
	//fseek(fp, -5, SEEK_CUR);//从文件的当前位置移动
	
	rewind(fp);//rewind()函数的功能是将文件的光标置首

#endif

	char buf[32] = { 0 };
	fgets(buf, sizeof(buf), fp);
	printf("%s\n", buf);

	fclose(fp);
}
```

### 10.6.2 ftell 函数：获取文件光标的读写位置

​	==统计文件大小的字节数==

```c
#include <stdio.h>
long ftell(FILE *stream);
功能：获取文件流（文件光标）的读写位置。
参数：
	stream：已经打开的文件指针
返回值：
	成功：当前文件流（文件光标）的读写位置
	失败：-1
```

```c
void test02()
{
	FILE* fp = fopen("test07.txt", "r");

	//移动光标  到文件尾
	fseek(fp, 0, SEEK_END);

	//读取文件尾的位置：从而得到文件的大小
	long len = ftell(fp);

	printf("len = %ld\n", len);//文件大小  11字节

	//将文件数据读取出来，并且放入到一个堆区数组
	//堆区申请空间
	char* p = malloc(len + 1);//加1预留一个\0
	memset(p, 0, len + 1);//清空内存

	//将光标置首
	rewind(fp);

	//按块读数据
	fread(p, len, 1, fp);

	//打印字符串
	printf("%s\n", p);

	//是否字符数组
	if (p != NULL)
	{
		free(p);
		p = NULL;
	}

	fclose(fp);
}
```

### 10.6.3 rewind 函数：将文件光标移到文件开头

```c
#include <stdio.h>
void rewind(FILE *stream);
功能：把文件流（文件光标）的读写位置移动到文件开头。
参数：
	stream：已经打开的文件指针
返回值：
	无返回值
```

```c
	// 解决办法二：利用函数将光标放回到原始位置
	// 也有以下几种方法：
	//fseek(fp, 0, SEEK_SET);//从文件起始位置移动

	//fseek(fp, -11, SEEK_END);//从文件结束位置移动

	//fseek(fp, 0, SEEK_END);
	//fseek(fp, -5, SEEK_CUR);//从文件的当前位置移动
	
	rewind(fp);//rewind()函数的功能是将文件的光标置首
```

## 10.7 Windows 和 Linux 中文本文件的区别

* b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的

* Unix和Linux下所有的文本文件行都是\n结尾，而Windows所有的文本文件行都是\r\n结尾

* **在Windows平台下，以“文本”方式打开文件，不加b：**

​		**1）当读取文件的时候，系统会将所有的 "\r\n" 转换成 "\n"**

​		**2）当写入文件的时候，系统会将 "\n" 转换成 "\r\n" 写入** 

​		**3）以"二进制"方式打开文件，则读\写都不会进行这样的转换**

在Unix/Linux平台下，“文本”与“二进制”模式没有区别，"\r\n" 作为两个字符原样输入输出。



判断文本文件是Linux格式还是Windows格式：

```c
#include<stdio.h>

int main(int argc, char **args)
{
	if (argc < 2)
		return 0;

	FILE *p = fopen(args[1], "rb");
	if (!p)
    {
		return 0;        
    }
	char a[1024] = { 0 };
	fgets(a, sizeof(a), p);

	int len = 0;
	while (a[len])
	{
		if (a[len] == '\n')
		{
			if (a[len - 1] == '\r')
			{
				printf("windows file\n");
			}
			else
			{
				printf("linux file\n");
			}
		}
		len++;
	}
	fclose(p);
	return 0;
}
```

## 10.8 系统文件指针 stdin、stdout、stderr

### （1）stdin ：当前终端为键盘

```c
void test01()
{
	int a = 0;
	printf("请重新给a赋值：\n");

	//关闭掉系统的输入指针（stdin）后面的代码相当于把键盘屏蔽掉了
	fclose(stdin);

	scanf("%d", &a);
	printf("a=%d\n", a);
}
```

### （2）stdout ：当前终端为屏幕

```c
void test02()
{
	printf("hello world1\n");
	printf("hello world2\n");

	//关闭文件输出指针（stdout）后面的代码相当于把屏幕屏蔽掉了
	fclose(stdout);//有的vs版本不同，有些不会奔溃，有些直接奔溃

	printf("hello world3\n");
	printf("hello world4\n");
	printf("hello world5\n");
}
```

### （3）stderr ：当前终端为屏幕

```c
void test03()
{
	FILE* fp = fopen("test08.txt", "r");
	if (fp == NULL)
	{
		perror("错误信息");
	}

	//如果是fclose(stdout)，则下面的代码不会执行
	fclose(stderr);//将下面这行关闭掉，关闭错误调试指针
	perror("错误信息");
	printf("hello world\n");//不影响这行输出
}
```

## 10.9 文件状态获取 stat（两种方式处理换行符）

```c
#include <sys/types.h>
#include <sys/stat.h>
int stat(const char *path, struct stat *buf);
功能：获取文件状态信息
参数：
path：文件名
buf：保存文件信息的结构体
返回值：
成功：0
失败-1
```

```c
struct stat {
	dev_t         st_dev;         //文件的设备编号
	ino_t         st_ino;          //节点
	mode_t        st_mode;   //文件的类型和存取的权限
	nlink_t       st_nlink;     //连到该文件的硬连接数目，刚建立的文件值为1
	uid_t         st_uid;         //用户ID
	gid_t         st_gid;         //组ID
	dev_t         st_rdev;      //(设备类型)若此文件为设备文件，则为其设备编号
	off_t         st_size;        //文件字节数(文件大小)
	unsigned long st_blksize;   //块大小(文件系统的I/O 缓冲区大小)
	unsigned long st_blocks;    //块数
	time_t        st_atime;     //最后一次访问时间
	time_t        st_mtime;    //最后一次修改时间
	time_t        st_ctime;     //最后一次改变时间(指属性)
};
```

​	==获取文件状态信息==

```c
void test01()
{
	struct stat myStat;
	stat("test07.txt", &myStat);//获取文件状态函数

	printf("文件的大小：%d\n", myStat.st_size);//获取文件大小

	//获取atime   访问时间
	char* time = ctime(&myStat.st_atime);//获取文件访问时间
	//printf("atime = %s", time);

	//处理换行符 
	//方式一：
	char atime[1024] = { 0 };
	//strcpy(atime, time);//将所有元素拷贝过来，包括\n
	//atime[strlen(atime) - 1] = '\0';
	//printf("atime = %s", atime);

	//方式二：
	strncpy(atime, time, strlen(time) - 1);//将除了最后一个\n的元素拷贝过来
	printf("atime = %s\n", atime);

	//获取mtime  modify time修改时间
	char* time2 = ctime(&myStat.st_mtime);
	char mtime[1024] = { 0 };
	strncpy(mtime, time2, strlen(time2) - 1);
	printf("atime = %s\n", mtime);
}
```

## 10.10 删除文件 remove、重命名文件 rename

### 10.10.1 删除文件 remove

```c
#include <stdio.h>
int remove(const char *pathname);
功能：删除文件
参数：
	pathname：文件名
返回值：
	成功：0
	失败：-1
```

### 10.10.2 重命名文件 rename

```c
#include <stdio.h>
int rename(const char *oldpath, const char *newpath);
功能：把oldpath的文件名改为newpath
参数：
oldpath：旧文件名
newpath：新文件名
返回值：
成功：0
失败： - 1
```

```c
void test02()
{
	//重命名rename(旧名称,新名称)
	rename("test07.txt", "test08.txt");

	//删除文件remove
	if (remove("test07.txt")==0)
	{
		printf("删除成功\n");
	}
	else
	{
		printf("删除失败\n");
	}
}
```

## 10.11 文件缓冲区

![2.97 文件缓冲区概念](E:\HUST\The future\后端学习\C\C学习代码（手敲）\02 C语言基础\2.97 文件缓冲区概念.png)

### 10.11.1 缓冲文件系统

* ANSI C标准采用“缓冲文件系统”处理数据文件。

* 所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内

  存中的缓冲区，装满缓冲区后才一起送到磁盘去。

* 如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程

  序数据区(给程序变量) 。

### 10.11.2 磁盘文件的存取

![img](file:///C:\Users\wenca\AppData\Local\Temp\ksohtml\wps3990.tmp.jpg)

* 磁盘文件，一般保存在硬盘、U盘等掉电不丢失的磁盘设备中，在需要时调入内存。

* 在内存中对文件进行编辑处理后，保存到磁盘中。

* ==程序与磁盘之间交互，不是立即完成，系统或程序可根据需要设置缓冲区，以提高存取效率==。

### 10.11.3 更新缓冲区

```c
#include <stdio.h>
int fflush(FILE *stream);
功能：更新缓冲区，让缓冲区的数据立马写到文件中。
参数：
stream：文件指针
返回值：
成功：0
失败：-1
```

